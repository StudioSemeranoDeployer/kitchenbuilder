<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Kitchen Builder - Quote & Zoom</title>
    <style>
        /* UI SYSTEM */
        :root { --primary: #2980b9; --dark: #2c3e50; --light: #ecf0f1; --accent: #e67e22; }
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: var(--dark); user-select: none; }
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #1e272e; color: white; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 10000; transition: opacity 0.8s;
        }
        .loader-ring { width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.1); border-top: 4px solid var(--primary); border-radius: 50%; animation: spin 1s infinite linear; margin-bottom: 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* PANNELLI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        .panel {
            pointer-events: auto; background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px); border-radius: 8px; padding: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.5);
            margin-bottom: 10px;
        }

        #toolbar { position: absolute; top: 20px; left: 20px; display: flex; flex-direction: column; gap: 10px; width: 200px; }
        
        h3 { margin: 0 0 8px 0; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; color: #7f8c8d; border-bottom: 1px solid #ddd; padding-bottom: 4px; }
        
        .btn {
            background: var(--dark); color: white; border: none; padding: 8px 12px; width: 100%;
            border-radius: 4px; font-weight: 600; cursor: pointer; display: flex; justify-content: center; align-items: center; gap: 8px;
            font-size: 12px; transition: all 0.2s; margin-bottom: 5px;
        }
        .btn:hover { background: var(--primary); }
        .btn-accent { background: var(--accent); }
        .btn-accent:hover { background: #d35400; }
        
        /* CONTAINER QUOTE */
        #quotes-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; }
        
        .quote-label {
            position: absolute; background: rgba(44, 62, 80, 0.85); color: white;
            padding: 2px 6px; border-radius: 3px; font-size: 10px; font-family: monospace;
            transform: translate(-50%, -100%); white-space: nowrap; pointer-events: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.3);
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="loader-ring"></div>
        <div style="font-size: 12px; letter-spacing: 1px;">CARICAMENTO...</div>
    </div>

    <!-- Layer per le etichette delle quote -->
    <div id="quotes-layer"></div>

    <div id="ui-layer">
        <div id="toolbar">
            <div class="panel">
                <h3>Progetto</h3>
                <button class="btn" onclick="window.app.saveProject()">üíæ Salva</button>
                <button class="btn" onclick="window.app.loadProject()">üìÇ Carica</button>
                <button class="btn" onclick="window.app.generateRandom()">üé≤ Random</button>
            </div>
            
            <div class="panel">
                <h3>Tools</h3>
                <button class="btn btn-accent" onclick="window.app.takePhoto()">üì∑ Foto</button>
                <button class="btn" id="btn-quotes" onclick="window.app.toggleQuotes()">üìè Quote: OFF</button>
                <div style="font-size:10px; color:#666; margin-top:5px; text-align:center;">
                    Doppio click: Apri<br>Shift+Click: Multi-Select
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- TEXTURE MANAGER PROCEDURALE ---
        class TextureManager {
            constructor() { this.cache = {}; }

            getWood(colorHex) {
                const key = `wood_${colorHex}`;
                if (this.cache[key]) return this.cache[key];

                const size = 512;
                const cvs = document.createElement('canvas'); cvs.width = size; cvs.height = size;
                const ctx = cvs.getContext('2d');
                ctx.fillStyle = colorHex; ctx.fillRect(0,0,size,size);
                
                // Venature leggere
                ctx.globalAlpha = 0.1; ctx.globalCompositeOperation = 'multiply';
                for(let i=0; i<30; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, Math.random()*size);
                    ctx.bezierCurveTo(size/2, Math.random()*size, size/2, Math.random()*size, size, Math.random()*size);
                    ctx.lineWidth = 2 + Math.random()*5; ctx.stroke();
                }

                const tex = new THREE.CanvasTexture(cvs);
                const mat = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.5, metalness: 0.1 });
                this.cache[key] = mat;
                return mat;
            }

            // Nuova texture Piastrelle
            getTiles(colorHex) {
                const key = `tiles_${colorHex}`;
                if (this.cache[key]) return this.cache[key];
                
                const size = 512;
                const cvs = document.createElement('canvas'); cvs.width = size; cvs.height = size;
                const ctx = cvs.getContext('2d');
                
                ctx.fillStyle = colorHex; ctx.fillRect(0,0,size,size);
                
                // Disegna griglia fughe
                ctx.strokeStyle = '#aaaaaa'; ctx.lineWidth = 2; ctx.globalAlpha = 0.3;
                const tileS = 64; // dimensione piastrella simulata
                for(let i=0; i<=size; i+=tileS) {
                    ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,size); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(size,i); ctx.stroke();
                }

                const tex = new THREE.CanvasTexture(cvs);
                tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
                tex.repeat.set(4,4); // Ripeti per coprire il piano
                
                const mat = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.8 });
                this.cache[key] = mat;
                return mat;
            }
        }

        // --- VARIABILI GLOBALI ---
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let texManager;
        
        let cabinets = [];
        let selection = [];
        let selectionHelpers = [];
        let quoteHelpers = []; // Box blu per le quote
        let quoteElements = []; // Elementi DOM per le quote
        
        let floorMesh, wallMesh;
        let ambientLight, sunLight;
        let isQuotesMode = false;

        const config = { step: 2, fastStep: 10, gridSize: 3000 };
        
        const props = {
            showFloor: true,
            showWall: true,
            light: 0.8,
            
            type: 'base', color: 'white', 
            width: 60, height: 85, depth: 60, elevation: 0, isOpen: false,
            
            addBase: () => linearSpawn('base'),
            addSink: () => linearSpawn('sink'),
            addCook: () => linearSpawn('cooktop'),
            addTall: () => linearSpawn('tall'),
            addFridge: () => linearSpawn('fridge'),
            addWall: () => linearSpawn('wall'),
            
            addBoard: () => linearSpawn('board_h'),
            addDoor: () => linearSpawn('door'),
            addWindow: () => linearSpawn('window'),
            
            deleteSel: () => deleteSelection()
        };

        const gui = new GUI({ title: 'Menu', width: 250 });
        const ctrls = {};

        window.app = {
            saveProject: saveToJSON,
            loadProject: loadFromJSON,
            generateRandom: generateRandomKitchen,
            takePhoto: takePhoto,
            toggleQuotes: toggleQuotesMode
        };

        init();

        function init() {
            texManager = new TextureManager();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdce4eb);
            scene.fog = new THREE.Fog(0xdce4eb, 800, 3000);

            // --- CAMERA ZOOMATA ---
            const aspect = window.innerWidth / window.innerHeight;
            // Ridotto 'd' da 500 a 350 per zoomare
            const d = 350; 
            camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 1, 5000);
            camera.position.set(400, 400, 400); // Pi√π vicina
            camera.lookAt(0, 50, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Luci
            ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(300, 800, 500);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.set(2048, 2048);
            scene.add(sunLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            createEnv();
            setupGUI();

            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', onKeyDown);
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            renderer.domElement.addEventListener('dblclick', onDoubleClick);

            setTimeout(() => document.getElementById('loader').style.opacity = 0, 800);
            setTimeout(() => document.getElementById('loader').remove(), 1600);

            // Start random
            generateRandomKitchen();

            animate();
        }

        // --- TEXTURES & MATERIALS ---
        function getMaterial(name) {
            const map = {
                white: '#ffffff',
                oak: '#d4c5a9',
                walnut: '#5d4037',
                dark: '#34495e'
            };
            if(map[name]) return texManager.getWood(map[name]);

            if(name==='glass') return new THREE.MeshPhysicalMaterial({color:0x88ccff, transmission:0.9, transparent:true, opacity:0.3, roughness:0});
            if(name==='top') return texManager.getTiles('#333333'); // Top scuro texture

            const m = {
                wall_white: new THREE.MeshStandardMaterial({color:0xf5f5f5}),
                steel: new THREE.MeshStandardMaterial({color:0xbdc3c7, metalness:0.6, roughness:0.3}),
                kick: texManager.getWood('#eeeeee'),
                black: new THREE.MeshStandardMaterial({color:0x111111})
            };
            return m[name] || m.wall_white;
        }

        function createEnv() {
            // PAVIMENTO PIASTRELLATO
            const fGeo = new THREE.PlaneGeometry(config.gridSize, config.gridSize);
            const fMat = texManager.getTiles('#f0f0f0'); 
            floorMesh = new THREE.Mesh(fGeo, fMat);
            floorMesh.rotation.x = -Math.PI/2; floorMesh.position.y = -0.1;
            floorMesh.receiveShadow = true;
            scene.add(floorMesh);

            const grid = new THREE.GridHelper(config.gridSize, 60, 0xbdc3c7, 0xffffff);
            grid.material.opacity = 0.2; grid.material.transparent = true;
            scene.add(grid);

            const wGeo = new THREE.BoxGeometry(config.gridSize, 500, 10);
            wallMesh = new THREE.Mesh(wGeo, getMaterial('wall_white'));
            wallMesh.position.set(0, 250, -150);
            wallMesh.receiveShadow = true;
            scene.add(wallMesh);
        }

        // --- LOGIC ---
        function linearSpawn(type) {
            const defs = { 
                base:[85,0,60], sink:[85,0,60], cooktop:[85,0,60], 
                tall:[215,0,60], fridge:[215,0,60], wall:[72,145,35],
                board_h:[4,0,30], door:[210,0,10], window:[120,100,10]
            };
            
            const [h, y, d] = defs[type];
            let w = (type==='window') ? 120 : (type==='door'?90:60);
            
            let tx=0, tz=0, trot=0, tcol=props.color;

            if(cabinets.length > 0) {
                const last = cabinets[cabinets.length-1];
                const lp = last.params;
                if(!['window','door','board_h'].includes(type)) tcol = lp.color;
                trot = lp.rotation;
                const rad = trot * (Math.PI/180);
                const dist = (lp.width/2)+(w/2);
                tx = lp.x + Math.cos(rad)*dist;
                tz = lp.z + Math.sin(rad)*dist;
            }

            const params = { id: crypto.randomUUID(), type, color: tcol, width: w, height: h, depth: d, elevation: y, rotation: trot, x: tx, z: tz, isOpen: false };
            createCabinet(params, true);
        }

        function createCabinet(params, selectIt=false) {
            const mesh = buildMesh(params);
            mesh.userData = { isCab: true, id: params.id };
            scene.add(mesh);
            const obj = { mesh, params };
            cabinets.push(obj);
            if(selectIt) select([obj]);
            if(isQuotesMode) refreshQuotes(); // Aggiorna le quote se attive
        }

        function buildMesh(p) {
            const grp = new THREE.Group();
            grp.position.set(p.x, p.elevation, p.z);
            grp.rotation.y = p.rotation * (Math.PI/180);

            // Speciali
            if(p.type === 'window') {
                const fr = getMaterial(p.color);
                const frame = new THREE.Group();
                // Telaio semplice
                const t = new THREE.Mesh(new THREE.BoxGeometry(p.width, 5, p.depth), fr); t.position.y=p.height/2;
                const b = new THREE.Mesh(new THREE.BoxGeometry(p.width, 5, p.depth), fr); b.position.y=-p.height/2;
                const l = new THREE.Mesh(new THREE.BoxGeometry(5, p.height, p.depth), fr); l.position.x=-p.width/2+2.5;
                const r = new THREE.Mesh(new THREE.BoxGeometry(5, p.height, p.depth), fr); r.position.x=p.width/2-2.5;
                const gl = new THREE.Mesh(new THREE.BoxGeometry(p.width-10, p.height-10, 2), getMaterial('glass'));
                frame.add(t,b,l,r,gl); frame.position.y = p.height/2;
                grp.add(frame); return grp;
            }
            if(p.type === 'door') {
                const fr = getMaterial(p.color);
                const f = new THREE.Group();
                const t = new THREE.Mesh(new THREE.BoxGeometry(p.width, 5, p.depth), fr); t.position.y=p.height;
                const l = new THREE.Mesh(new THREE.BoxGeometry(5, p.height, p.depth), fr); l.position.set(-p.width/2+2.5, p.height/2, 0);
                const r = new THREE.Mesh(new THREE.BoxGeometry(5, p.height, p.depth), fr); r.position.set(p.width/2-2.5, p.height/2, 0);
                f.add(t,l,r); grp.add(f); return grp;
            }

            // Moduli Standard
            const toeH = (p.type.startsWith('board') || ['wall','fridge'].includes(p.type)) ? 0 : 10;
            const topH = (['base','sink','cooktop'].includes(p.type)) ? 4 : 0;
            const bodyH = p.height - toeH - topH;
            const mat = getMaterial(p.color);

            const box = new THREE.Mesh(new THREE.BoxGeometry(p.width, bodyH, p.depth), mat);
            box.position.y = toeH + bodyH/2;
            box.castShadow = true; box.receiveShadow = true;
            if(mat.map) mat.map.repeat.set(p.width/100, bodyH/100);
            grp.add(box);

            if(topH>0) {
                const top = new THREE.Mesh(new THREE.BoxGeometry(p.width, topH, p.depth+2), getMaterial('top'));
                top.position.set(0, toeH+bodyH+topH/2, 1);
                top.castShadow=true; grp.add(top);
            }
            if(toeH>0) {
                const kick = new THREE.Mesh(new THREE.BoxGeometry(p.width-2, toeH, p.depth-5), mat);
                kick.position.set(0, toeH/2, -2.5); grp.add(kick);
            }

            if(!p.type.startsWith('board') && p.type !== 'fridge') {
                const dGrp = new THREE.Group(); dGrp.position.set(0, toeH+bodyH/2, p.depth/2+1);
                const isD = p.width>=70;
                const dw = isD?(p.width/2)-0.2 : p.width-0.4;
                const dh = bodyH-0.4;
                if(isD) {
                    const d1=makeDoor(dw,dh,mat,-1); d1.position.x=-p.width/4;
                    const d2=makeDoor(dw,dh,mat,1); d2.position.x=p.width/4;
                    if(p.isOpen){ d1.rotation.y=1.5; d2.rotation.y=-1.5; }
                    dGrp.add(d1,d2);
                } else {
                    const d1=makeDoor(dw,dh,mat,1);
                    if(p.isOpen) { d1.rotation.y=1.5; d1.position.x+=dw/2; }
                    dGrp.add(d1);
                }
                grp.add(dGrp);
            } else if(p.type==='fridge') {
                const d = new THREE.Mesh(new THREE.BoxGeometry(p.width-1, p.height-2, 4), getMaterial('steel'));
                d.position.set(0, p.height/2, p.depth/2+2); grp.add(d);
            }

            if(p.type==='sink') {
                const b = new THREE.Mesh(new THREE.BoxGeometry(p.width-10, 14, p.depth-10), getMaterial('steel'));
                b.position.set(0, toeH+bodyH+2, 0);
                const t = new THREE.Mesh(new THREE.CylinderGeometry(1,1,20), getMaterial('steel'));
                t.position.set(0, toeH+bodyH+10, -10); t.rotation.x=0.3;
                grp.add(b,t);
            }
            if(p.type==='cooktop') {
                const pl = new THREE.Mesh(new THREE.BoxGeometry(p.width-12, 1, p.depth-12), getMaterial('black'));
                pl.position.set(0, toeH+bodyH+topH+0.5, 0); grp.add(pl);
            }

            return grp;
        }

        function makeDoor(w,h,m,d){
            const g=new THREE.Group();
            g.add(new THREE.Mesh(new THREE.BoxGeometry(w,h,2),m));
            const han=new THREE.Mesh(new THREE.BoxGeometry(1,12,1), getMaterial('steel'));
            han.position.set(d>0?-w/2+4:w/2-4, 0, 2); g.add(han);
            return g;
        }

        // --- GESTIONE SELEZIONE ---
        function onPointerDown(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(scene.children, true);
            let found = null;
            for(let h of hits) { let p=h.object; while(p){ if(p.userData?.isCab){found=p; break;} p=p.parent; } if(found) break; }

            const isShift = e.shiftKey;
            if(found) {
                const cab = cabinets.find(c => c.params.id === found.userData.id);
                if(isShift) {
                    const idx = selection.indexOf(cab);
                    if(idx>=0 && selection.length>1) { const s=[...selection]; s.splice(idx,1); select(s); }
                    else if(idx<0) select([...selection, cab]);
                } else { if(!selection.includes(cab)) select([cab]); }
            } else if(hits.length===0 || hits[0].object===floorMesh) { if(!isShift) select([]); }
        }

        function select(newSel) {
            selection = newSel;
            selectionHelpers.forEach(h => scene.remove(h));
            selectionHelpers = [];
            
            selection.forEach(cab => {
                const box = new THREE.BoxHelper(cab.mesh, 0xe67e22);
                scene.add(box);
                selectionHelpers.push(box);
            });

            if(selection.length > 0) {
                const p = selection[selection.length-1].params;
                Object.assign(props, { type: p.type, color: p.color, width: p.width, height: p.height, depth: p.depth, elevation: p.elevation, isOpen: p.isOpen });
                for(let k in ctrls) ctrls[k].updateDisplay();
            }
        }

        function updateMesh(cab) {
            scene.remove(cab.mesh);
            cab.mesh = buildMesh(cab.params);
            cab.mesh.userData = { isCab: true, id: cab.params.id };
            scene.add(cab.mesh);
        }

        function deleteSelection() {
            selection.forEach(c => { scene.remove(c.mesh); cabinets = cabinets.filter(x => x !== c); });
            select([]);
            if(isQuotesMode) refreshQuotes();
        }

        function onKeyDown(e) {
            if(selection.length === 0) return;
            const step = e.shiftKey ? config.fastStep : config.step;
            let changed=false, dx=0, dz=0, dRot=0;
            if(e.key==='ArrowLeft') dx=-step; if(e.key==='ArrowRight') dx=step;
            if(e.key==='ArrowUp') dz=-step; if(e.key==='ArrowDown') dz=step;
            if(e.key.toLowerCase()==='r') dRot=90;
            if(e.key==='Delete') { deleteSelection(); return; }

            if(dx||dz||dRot) {
                selection.forEach(c => {
                    c.params.x += dx; c.params.z += dz;
                    if(dRot) c.params.rotation = (c.params.rotation+dRot)%360;
                    c.mesh.position.set(c.params.x, c.params.elevation, c.params.z);
                    c.mesh.rotation.y = c.params.rotation * (Math.PI/180);
                });
                selectionHelpers.forEach(h=>h.update());
                if(isQuotesMode) refreshQuotes();
            }
        }
        function onDoubleClick() { selection.forEach(c=>{c.params.isOpen=!c.params.isOpen; updateMesh(c);}); select(selection); }

        // --- SISTEMA QUOTE (DIMENSIONI) ---
        function toggleQuotesMode() {
            isQuotesMode = !isQuotesMode;
            document.getElementById('btn-quotes').innerText = isQuotesMode ? "üìè Quote: ON" : "üìè Quote: OFF";
            if(isQuotesMode) refreshQuotes();
            else clearQuotes();
        }

        function clearQuotes() {
            quoteHelpers.forEach(h => scene.remove(h)); quoteHelpers = [];
            quoteElements.forEach(el => el.remove()); quoteElements = [];
        }

        function refreshQuotes() {
            clearQuotes();
            const layer = document.getElementById('quotes-layer');
            const boxMat = new THREE.LineBasicMaterial({ color: 0x3498db, depthTest: false, opacity:0.5, transparent:true });
            
            cabinets.forEach(cab => {
                // 1. Box Wireframe Blu
                const box = new THREE.BoxHelper(cab.mesh, 0x3498db);
                box.material = boxMat;
                scene.add(box);
                quoteHelpers.push(box);

                // 2. Etichetta HTML
                const el = document.createElement('div');
                el.className = 'quote-label';
                el.innerText = `${cab.params.width}x${cab.params.height}`;
                layer.appendChild(el);
                
                // Salviamo riferimento all'oggetto e all'elemento DOM
                quoteElements.push({ el: el, cab: cab });
            });
        }

        function updateQuotesPositions() {
            if(!isQuotesMode) return;
            
            quoteElements.forEach(item => {
                const p = item.cab.params;
                // Calcola posizione sopra il mobile
                const vec = new THREE.Vector3(p.x, p.elevation + p.height + 10, p.z);
                
                // Proietta in 2D
                vec.project(camera);
                
                // Controlla se √® nel frustum (approssimato)
                if(vec.z < 1 && vec.x > -1 && vec.x < 1 && vec.y > -1 && vec.y < 1) {
                    const x = (vec.x * .5 + .5) * window.innerWidth;
                    const y = (-(vec.y * .5) + .5) * window.innerHeight;
                    item.el.style.display = 'block';
                    item.el.style.left = x + 'px';
                    item.el.style.top = y + 'px';
                } else {
                    item.el.style.display = 'none';
                }
            });
        }

        // --- UTILS ---
        function saveToJSON() { const d=cabinets.map(c=>c.params); const b=new Blob([JSON.stringify(d)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='progetto.json'; a.click(); }
        function loadFromJSON() { const i=document.createElement('input'); i.type='file'; i.onchange=e=>{const r=new FileReader(); r.onload=ev=>loadData(JSON.parse(ev.target.result)); r.readAsText(e.target.files[0]);}; i.click(); }
        function loadData(d) { deleteSelection(); cabinets.forEach(c=>scene.remove(c.mesh)); cabinets=[]; d.forEach(p=>createCabinet(p)); }
        
        function generateRandomKitchen() {
            loadData([]);
            let x = -120;
            linearSpawn('fridge'); x+=60;
            linearSpawn('base'); x+=60;
            linearSpawn('sink'); x+=60;
            linearSpawn('cooktop'); x+=60;
            linearSpawn('tall');
            // Pensili
            cabinets.forEach(c => {
                if(['base','sink','cooktop'].includes(c.params.type)){
                   const p = {...c.params, id:crypto.randomUUID(), type:'wall', height:72, depth:35, elevation:145 };
                   createCabinet(p);
                }
            });
            controls.reset();
        }
        
        function takePhoto() { renderer.render(scene, camera); const a=document.createElement('a'); a.download='render.png'; a.href=renderer.domElement.toDataURL('image/png'); a.click(); }

        function setupGUI() {
            const apply = () => { selection.forEach(c => { Object.assign(c.params, props); updateMesh(c); }); if(selection.length>0) select(selection); if(isQuotesMode) refreshQuotes(); };
            const fEnv = gui.addFolder('üí° Ambiente');
            fEnv.add(props, 'showFloor').onChange(v=>floorMesh.visible=v);
            fEnv.add(props, 'showWall').onChange(v=>wallMesh.visible=v);
            fEnv.add(props, 'light', 0, 2).onChange(v=>sunLight.intensity=v);

            const fAdd = gui.addFolder('‚ûï Aggiungi');
            fAdd.add(props, 'addBase'); fAdd.add(props, 'addSink'); fAdd.add(props, 'addCook');
            fAdd.add(props, 'addTall'); fAdd.add(props, 'addFridge'); fAdd.add(props, 'addWall');
            fAdd.add(props, 'addBoard').name('Mensola');
            fAdd.add(props, 'addDoor').name('Porta');
            fAdd.add(props, 'addWindow').name('Finestra');

            const fEdit = gui.addFolder('üîß Modifica');
            ctrls.type = fEdit.add(props, 'type', ['base','sink','cooktop','tall','fridge','wall','board_h','door','window']).onChange(apply);
            ctrls.color = fEdit.add(props, 'color', ['white','oak','walnut','dark']).onChange(apply);
            ctrls.w = fEdit.add(props, 'width', 1, 300, 1).onChange(apply);
            ctrls.h = fEdit.add(props, 'height', 1, 300, 1).onChange(apply);
            ctrls.d = fEdit.add(props, 'depth', 1, 200, 1).onChange(apply);
            ctrls.elv = fEdit.add(props, 'elevation', 0, 300, 1).onChange(apply);
            ctrls.opn = fEdit.add(props, 'isOpen').onChange(apply);
            fEdit.add(props, 'deleteSel');
            fAdd.open();
        }

        function onResize() {
            const d=350; const asp=window.innerWidth/window.innerHeight;
            camera.left=-d*asp; camera.right=d*asp; camera.top=d; camera.bottom=-d;
            camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            updateQuotesPositions();
        }
    </script>
</body>
</html>
