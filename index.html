<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Kitchen Builder Ultimate - Cream UX</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        /* --- DESIGN SYSTEM (Cream & Glass) --- */
        :root { 
            --primary: #c58f68; /* Legno caldo */
            --dark: #3e3a36; 
            --bg-gradient: linear-gradient(135deg, #fdfbf7 0%, #f3efe7 100%);
            --glass: rgba(255, 255, 255, 0.85);
            --glass-border: 1px solid rgba(255, 255, 255, 0.6);
            --shadow: 0 8px 32px rgba(62, 58, 54, 0.1);
            --accent: #e07a5f;
        }

        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg-gradient); touch-action: none; }
        
        /* LOADER */
        #loader {
            position: fixed; inset: 0; z-index: 10000;
            background: #fdfbf7; display: flex; flex-direction: column;
            justify-content: center; align-items: center; transition: opacity 0.6s;
        }
        .loader-icon { font-size: 40px; animation: bounce 1s infinite; margin-bottom: 15px; }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }

        /* UI CONTAINER */
        #ui-layer { position: absolute; inset: 0; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; overflow: hidden; }

        /* --- TOOLBAR (BOTTOM/SIDE) --- */
        #toolbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 800px;
            display: flex; gap: 12px; pointer-events: auto;
            overflow-x: auto; padding: 10px;
            /* Scrollbar invisibile */
            scrollbar-width: none; -ms-overflow-style: none;
        }
        #toolbar::-webkit-scrollbar { display: none; }

        .panel {
            background: var(--glass); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: var(--glass-border); border-radius: 16px; padding: 12px;
            box-shadow: var(--shadow);
            display: flex; flex-direction: column; gap: 8px;
            min-width: max-content;
            transition: transform 0.2s;
        }
        
        .panel-title { 
            font-size: 10px; text-transform: uppercase; letter-spacing: 1px; color: #8d7f75; 
            font-weight: 700; border-bottom: 1px solid rgba(0,0,0,0.05); padding-bottom: 4px; margin-bottom: 4px;
        }

        .btn-row { display: flex; gap: 6px; }

        .btn {
            background: rgba(255,255,255,0.6); border: 1px solid rgba(0,0,0,0.05);
            color: var(--dark); padding: 8px 14px; border-radius: 8px;
            font-size: 13px; font-weight: 600; cursor: pointer;
            display: flex; align-items: center; gap: 6px;
            transition: all 0.2s; white-space: nowrap;
        }
        .btn:hover { background: #fff; transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0,0,0,0.05); }
        .btn:active { transform: scale(0.96); }
        .btn.active { background: var(--primary); color: white; border-color: var(--primary); }
        .btn-accent { color: var(--accent); background: rgba(224, 122, 95, 0.1); }
        .btn-accent:hover { background: var(--accent); color: white; }

        /* --- CONTROLLI VIRTUALI (Floating) --- */
        #virtual-controls {
            position: absolute; right: 20px; bottom: 180px; /* Sopra la toolbar */
            display: flex; flex-direction: column; align-items: flex-end; gap: 10px;
            pointer-events: none; opacity: 0; transition: opacity 0.3s, transform 0.3s;
            transform: translateY(20px);
        }
        #virtual-controls.visible { opacity: 1; pointer-events: auto; transform: translateY(0); }

        .d-pad { 
            background: var(--glass); padding: 8px; border-radius: 50%; 
            display: grid; grid-template-columns: repeat(3, 40px); gap: 4px; 
            box-shadow: var(--shadow); backdrop-filter: blur(10px);
        }
        .ctrl-btn {
            width: 40px; height: 40px; border-radius: 10px; border: none;
            background: rgba(255,255,255,0.5); color: var(--dark);
            font-size: 18px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: background 0.2s;
        }
        .ctrl-btn:active { background: var(--primary); color: white; }
        .action-row { display: flex; gap: 8px; margin-top: 5px; }
        .btn-del { background: #ffebeb; color: #d63031; }
        .btn-del:active { background: #d63031; color: white; }

        /* --- NOTIFICHE & TOOLTIP --- */
        #measure-tooltip {
            position: absolute; top: 0; left: 0;
            background: rgba(44, 44, 44, 0.9); color: white;
            padding: 4px 10px; border-radius: 20px; font-size: 11px; font-weight: 600;
            pointer-events: none; opacity: 0; transform: translate(-50%, -100%);
            margin-top: -10px; white-space: nowrap; z-index: 2000;
        }
        #toast {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: var(--dark); color: white; padding: 10px 20px; border-radius: 30px;
            font-size: 13px; opacity: 0; transition: opacity 0.3s; pointer-events: none;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        /* MEDIA QUERIES */
        @media (min-width: 769px) {
            #toolbar { 
                bottom: auto; top: 20px; left: 20px; transform: none; 
                flex-direction: column; width: auto; max-height: 90vh; 
            }
            .panel { width: 220px; }
            .btn-row { flex-wrap: wrap; }
            #virtual-controls { bottom: 40px; }
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="loader-icon">üõãÔ∏è</div>
        <div style="letter-spacing: 2px; font-size: 14px; color:#555;">KITCHEN BUILDER</div>
    </div>

    <div id="ui-layer">
        <div id="toast">Messaggio Sistema</div>
        
        <div id="toolbar">
            <!-- PROGETTO -->
            <div class="panel">
                <div class="panel-title">Progetto</div>
                <div class="btn-row">
                    <button class="btn" onclick="app.saveProject()">üíæ Salva</button>
                    <button class="btn" onclick="app.loadProject()">üìÇ Apri</button>
                    <button class="btn btn-accent" onclick="app.generateRandom()">üé≤ Random</button>
                </div>
            </div>

            <!-- VISUALIZZA -->
            <div class="panel">
                <div class="panel-title">Strumenti</div>
                <div class="btn-row">
                    <button class="btn" onclick="app.takePhoto()">üì∑ Foto</button>
                    <button class="btn" id="btn-quotes" onclick="app.toggleQuotes()">üìè Quote: OFF</button>
                </div>
            </div>

            <!-- AGGIUNGI -->
            <div class="panel">
                <div class="panel-title">Aggiungi Modulo</div>
                <div class="btn-row" style="flex-wrap: nowrap; overflow-x: auto; padding-bottom: 5px;">
                    <button class="btn" onclick="app.spawn('base')">Base</button>
                    <button class="btn" onclick="app.spawn('sink')">Lavello</button>
                    <button class="btn" onclick="app.spawn('cooktop')">Fuochi</button>
                    <button class="btn" onclick="app.spawn('fridge')">Frigo</button>
                    <button class="btn" onclick="app.spawn('tall')">Colonna</button>
                    <button class="btn" onclick="app.spawn('wall')">Pensile</button>
                </div>
            </div>
        </div>

        <!-- PAD CONTROLLO -->
        <div id="virtual-controls">
            <div class="d-pad">
                <div></div>
                <button class="ctrl-btn" onpointerdown="app.startMove(0, -1)" onpointerup="app.stopMove()">‚ñ≤</button>
                <div></div>
                <button class="ctrl-btn" onpointerdown="app.startMove(-1, 0)" onpointerup="app.stopMove()">‚óÑ</button>
                <button class="ctrl-btn" onpointerdown="app.startMove(0, 1)" onpointerup="app.stopMove()">‚ñº</button>
                <button class="ctrl-btn" onpointerdown="app.startMove(1, 0)" onpointerup="app.stopMove()">‚ñ∫</button>
            </div>
            <div class="action-row">
                <button class="ctrl-btn" onclick="app.rotate()">‚Üª</button>
                <button class="ctrl-btn" onclick="app.openDoor()">üö™</button>
                <button class="ctrl-btn btn-del" onclick="app.delete()">üóë</button>
            </div>
        </div>

        <div id="measure-tooltip"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- SISTEMA TEXTURE ---
        class TextureManager {
            constructor() { this.cache = {}; }
            getWood(hex) {
                const k = 'w_'+hex; if(this.cache[k]) return this.cache[k];
                const c = document.createElement('canvas'); c.width=256; c.height=256;
                const ctx = c.getContext('2d');
                ctx.fillStyle = hex; ctx.fillRect(0,0,256,256);
                ctx.globalAlpha = 0.06;
                for(let i=0; i<30; i++) {
                    ctx.beginPath(); ctx.moveTo(0, Math.random()*256);
                    ctx.bezierCurveTo(80, Math.random()*256, 170, Math.random()*256, 256, Math.random()*256);
                    ctx.strokeStyle = '#6b5b4e'; ctx.stroke();
                }
                const tex = new THREE.CanvasTexture(c);
                const mat = new THREE.MeshStandardMaterial({ map:tex, roughness:0.6, metalness:0.05 });
                this.cache[k] = mat; return mat;
            }
            getStone(hex) {
                const k = 's_'+hex; if(this.cache[k]) return this.cache[k];
                const c = document.createElement('canvas'); c.width=256; c.height=256;
                const ctx = c.getContext('2d'); ctx.fillStyle = hex; ctx.fillRect(0,0,256,256);
                ctx.globalAlpha = 0.08;
                for(let i=0; i<1000; i++) {
                    ctx.fillStyle = Math.random()>0.5?'#fff':'#555';
                    ctx.fillRect(Math.random()*256, Math.random()*256, 2, 2);
                }
                const mat = new THREE.MeshStandardMaterial({ map:new THREE.CanvasTexture(c), roughness:0.9 });
                this.cache[k] = mat; return mat;
            }
        }

        // --- VARIABILI GLOBALI ---
        let scene, camera, renderer, controls;
        let raycaster, mouse, texManager;
        let cabinets = [], selection = [], selectionHelpers = [];
        let quoteGroup = null;
        let floorMesh, wallMesh;
        let isQuotesMode = false;
        let moveInterval = null;
        let mouseDownPos = new THREE.Vector2();

        // Config
        const config = { step: 2, gridSize: 1800 };
        const props = {
            type: 'base', color: 'cream', width: 60, height: 85, depth: 60, elevation: 0,
            showFloor: true, showWall: true, wallColor: 'wall_cream',
            deleteSel: () => deleteSelection()
        };

        const gui = new GUI({ title: 'Dettagli', width: 260 }); 
        gui.close();
        const ctrls = {};

        // --- PUBLIC API ---
        window.app = {
            spawn: (t) => linearSpawn(t),
            saveProject: saveToJSON,
            loadProject: loadFromJSON,
            generateRandom: generateRandomKitchen,
            takePhoto: takePhoto,
            toggleQuotes: toggleQuotesMode,
            startMove: (x, z) => { moveSelection(x, z); moveInterval = setInterval(()=>moveSelection(x,z), 100); },
            stopMove: () => clearInterval(moveInterval),
            rotate: () => rotateSelection(),
            delete: () => deleteSelection(),
            openDoor: () => { selection.forEach(c => { c.params.isOpen = !c.params.isOpen; rebuildCabinet(c); }); select(selection); }
        };

        init();

        function init() {
            texManager = new TextureManager();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xfcfbf4); 
            scene.fog = new THREE.Fog(0xfcfbf4, 400, 1500);

            const aspect = window.innerWidth / window.innerHeight;
            // ZOOM IN: Valore 'd' ridotto per avvicinare la camera
            const d = window.innerWidth < 768 ? 260 : 200; 
            camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 1, 4000);
            camera.position.set(300, 300, 300); 
            camera.lookAt(0, 40, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // LUCI
            const amb = new THREE.AmbientLight(0xfff5e6, 0.75);
            scene.add(amb);
            const sun = new THREE.DirectionalLight(0xffffff, 0.6);
            sun.position.set(150, 400, 200);
            sun.castShadow = true;
            sun.shadow.mapSize.set(1024, 1024);
            sun.shadow.bias = -0.0005;
            scene.add(sun);

            // CONTROLLI
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.08;
            controls.maxPolarAngle = Math.PI / 2; // Niente sotto terra
            controls.target.set(0, 40, 0);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            quoteGroup = new THREE.Group();
            scene.add(quoteGroup);

            createEnv();
            setupGUI();

            window.addEventListener('resize', onResize);
            renderer.domElement.addEventListener('pointerdown', e => mouseDownPos.set(e.clientX, e.clientY));
            renderer.domElement.addEventListener('pointerup', onPointerUp);

            setTimeout(() => {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').remove(), 600);
            }, 800);

            animate();
        }

        // --- AMBIENTE ---
        function getMaterial(n) {
            const p = { cream:'#fbf6e9', oak:'#dcbba0', walnut:'#a0886f', sand:'#d4cbb3', kick:'#dcdcdc' };
            if(p[n]) return texManager.getWood(p[n]);
            if(n==='glass') return new THREE.MeshPhysicalMaterial({ color:0xddeeff, transmission:0.7, transparent:true, opacity:0.3 });
            
            const tech = {
                top: texManager.getStone('#edece6'),
                steel: new THREE.MeshStandardMaterial({ color:0xcccccc, metalness:0.6, roughness:0.4 }),
                black: new THREE.MeshStandardMaterial({ color:0x222222 }),
                wall_cream: new THREE.MeshStandardMaterial({ color:0xfcfcf7 })
            };
            return tech[n] || tech.wall_cream;
        }

        function createEnv() {
            // Muro: Spostato vicino ai mobili (z = -32)
            const w = new THREE.Mesh(new THREE.BoxGeometry(config.gridSize, 500, 10), getMaterial('wall_cream'));
            w.position.set(0, 250, -35); w.receiveShadow = true; scene.add(w);
            wallMesh = w;

            // Pavimento: Parte dal muro in poi
            const f = new THREE.Mesh(new THREE.PlaneGeometry(config.gridSize, config.gridSize/2), texManager.getStone('#e8e4dc'));
            f.rotation.x = -Math.PI/2; 
            f.position.set(0, -0.1, (config.gridSize/4) - 30);
            f.receiveShadow = true; scene.add(f);
            floorMesh = f;
            
            // Griglia decorativa
            const g = new THREE.GridHelper(config.gridSize, 40, 0xd4a373, 0xeaddcf);
            g.position.set(0, 0.1, (config.gridSize/4) - 30); g.material.opacity=0.3; g.material.transparent=true;
            scene.add(g);
        }

        // --- LOGICA MODULI ---
        function linearSpawn(type) {
            const defs = { 
                base:[85,0,60], sink:[85,0,60], cooktop:[85,0,60], 
                tall:[215,0,60], fridge:[215,0,60], wall:[72,145,35] 
            };
            if(!defs[type]) return;

            const [h, y, d] = defs[type];
            let w = 60; 
            let tx = 0, tz = 0, trot = 0;
            let col = props.color;

            if (cabinets.length > 0) {
                const last = cabinets[cabinets.length - 1];
                const lp = last.params;
                if(!['led','glass'].includes(lp.color)) col = lp.color;
                
                // Calcolo posizione successiva semplice
                const rad = lp.rotation * (Math.PI/180);
                const dist = (lp.width/2) + (w/2);
                tx = lp.x + Math.cos(rad) * dist;
                tz = lp.z + Math.sin(rad) * dist;
                trot = lp.rotation;
            }

            const p = {
                id: crypto.randomUUID(), type, color: col,
                width: w, height: h, depth: d, elevation: y,
                rotation: trot, x: tx, z: tz, isOpen: false
            };
            createCabinet(p, true);
        }

        function createCabinet(p, sel=false) {
            const mesh = buildMesh(p);
            mesh.userData = { isCab:true, id:p.id };
            scene.add(mesh);
            const obj = { mesh, params:p };
            cabinets.push(obj);
            if(sel) select([obj]);
            updateQuotes(); // Forza aggiornamento quote
        }

        function rebuildCabinet(cab) {
            scene.remove(cab.mesh);
            cab.mesh = buildMesh(cab.params);
            cab.mesh.userData = { isCab:true, id:cab.params.id };
            scene.add(cab.mesh);
        }

        function buildMesh(p) {
            const grp = new THREE.Group();
            grp.position.set(p.x, p.elevation, p.z);
            grp.rotation.y = p.rotation * (Math.PI/180);

            const toe = (p.type==='wall'||p.type==='fridge') ? 0 : 10;
            const top = (['base','sink','cooktop'].includes(p.type)) ? 4 : 0;
            const body = p.height - toe - top;
            const mat = getMaterial(p.color);

            // Box principale
            const box = new THREE.Mesh(new THREE.BoxGeometry(p.width, body, p.depth), mat);
            box.position.y = toe + body/2;
            box.castShadow = true; box.receiveShadow = true;
            if(mat.map) mat.map.repeat.set(p.width/100, body/100);
            grp.add(box);

            // Top
            if(top>0) {
                const t = new THREE.Mesh(new THREE.BoxGeometry(p.width, top, p.depth+2), getMaterial('top'));
                t.position.set(0, toe+body+top/2, 1); t.castShadow = true; grp.add(t);
            }
            // Zoccolo
            if(toe>0) {
                const k = new THREE.Mesh(new THREE.BoxGeometry(p.width-2, toe, p.depth-5), getMaterial('kick'));
                k.position.set(0, toe/2, -2.5); grp.add(k);
            }

            // Dettagli
            if(p.type==='fridge') {
                const f = new THREE.Mesh(new THREE.BoxGeometry(p.width-2, p.height-2, 2), mat);
                f.position.set(0, p.height/2, p.depth/2+1); grp.add(f);
            } else if (p.type !== 'fridge') {
                // Ante
                const dg = new THREE.Group(); dg.position.set(0, toe+body/2, p.depth/2+1);
                const is2 = p.width >= 70; const dw = is2 ? (p.width/2)-0.2 : p.width-0.4;
                if(is2) {
                    const d1=mkDoor(dw, body-0.4, mat, -1); d1.position.x = -p.width/4;
                    const d2=mkDoor(dw, body-0.4, mat, 1); d2.position.x = p.width/4;
                    if(p.isOpen) { d1.rotation.y=1.5; d2.rotation.y=-1.5; }
                    dg.add(d1, d2);
                } else {
                    const d1=mkDoor(dw, body-0.4, mat, 1);
                    if(p.isOpen) { d1.rotation.y=1.5; d1.position.x+=dw/2; }
                    dg.add(d1);
                }
                grp.add(dg);
            }

            if(p.type==='sink') {
                const s = new THREE.Mesh(new THREE.BoxGeometry(p.width-15, 15, p.depth-15), getMaterial('steel'));
                s.position.set(0, toe+body, 0); 
                const tap = new THREE.Mesh(new THREE.CylinderGeometry(1,1,15), getMaterial('steel'));
                tap.position.set(0, toe+body+8, -10); tap.rotation.x=0.3;
                grp.add(s, tap);
            }
            if(p.type==='cooktop') {
                const c = new THREE.Mesh(new THREE.BoxGeometry(p.width-15, 1, p.depth-15), getMaterial('black'));
                c.position.set(0, toe+body+top+0.5, 0); grp.add(c);
            }

            return grp;
        }

        function mkDoor(w, h, m, dir) {
            const g=new THREE.Group();
            const p=new THREE.Mesh(new THREE.BoxGeometry(w, h, 2), m); g.add(p);
            const hn=new THREE.Mesh(new THREE.BoxGeometry(1, 15, 1), getMaterial('steel'));
            hn.position.set(dir>0 ? -w/2+4 : w/2-4, 5, 2); g.add(hn);
            return g;
        }

        // --- GESTIONE AZIONI ---
        function moveSelection(dx, dz) {
            if(!selection.length) return;
            const s = config.step;
            selection.forEach(c => {
                c.params.x += dx*s; c.params.z += dz*s;
                c.mesh.position.set(c.params.x, c.params.elevation, c.params.z);
            });
            selectionHelpers.forEach(h=>h.update());
            updateTooltip();
            updateQuotes(); // Fondamentale per vedere le quote muoversi
        }

        function rotateSelection() {
            if(!selection.length) return;
            selection.forEach(c => {
                c.params.rotation = (c.params.rotation + 90) % 360;
                c.mesh.rotation.y = c.params.rotation * (Math.PI/180);
            });
            selectionHelpers.forEach(h=>h.update());
            updateQuotes();
        }

        function deleteSelection() {
            selection.forEach(c => { scene.remove(c.mesh); cabinets=cabinets.filter(x=>x!==c); });
            select([]);
            updateQuotes(); // Ridisegna quote senza l'oggetto eliminato
        }

        function onPointerUp(e) {
            if(mouseDownPos.distanceTo(new THREE.Vector2(e.clientX,e.clientY))>10) return;
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left)/rect.width)*2 -1;
            mouse.y = -((e.clientY - rect.top)/rect.height)*2 +1;
            raycaster.setFromCamera(mouse, camera);
            
            const hits = raycaster.intersectObjects(scene.children, true);
            let target = null;
            for(let h of hits) {
                let p = h.object;
                while(p) { if(p.userData?.isCab){target=p; break;} p=p.parent; }
                if(target) break;
            }

            if(target) {
                const c = cabinets.find(x=>x.params.id===target.userData.id);
                if(e.shiftKey) {
                    const i = selection.indexOf(c);
                    if(i>=0) { const s=[...selection]; s.splice(i,1); select(s); }
                    else select([...selection, c]);
                } else if(!selection.includes(c)) select([c]);
            } else if(!hits.length || hits[0].object===floorMesh) {
                if(!e.shiftKey) select([]);
            }
        }

        function select(arr) {
            selection = arr;
            selectionHelpers.forEach(h=>scene.remove(h)); selectionHelpers=[];
            selection.forEach(c => {
                const b = new THREE.BoxHelper(c.mesh, 0xe07a5f);
                scene.add(b); selectionHelpers.push(b);
            });
            
            const ctrls = document.getElementById('virtual-controls');
            if(selection.length) {
                ctrls.classList.add('visible');
                // Sync GUI
                const p = selection[0].params;
                Object.assign(props, { type:p.type, color:p.color, width:p.width });
                updateTooltip();
            } else {
                ctrls.classList.remove('visible');
                document.getElementById('measure-tooltip').style.opacity = 0;
            }
        }

        // --- SISTEMA QUOTE PERFETTO ---
        function toggleQuotesMode() {
            isQuotesMode = !isQuotesMode;
            const btn = document.getElementById('btn-quotes');
            btn.innerText = isQuotesMode ? "üìè Quote: ON" : "üìè Quote: OFF";
            btn.classList.toggle('active', isQuotesMode);
            updateQuotes();
        }

        function createLabel(txt) {
            const cv = document.createElement('canvas'); const cx = cv.getContext('2d');
            const fs = 40; cx.font = `bold ${fs}px Arial`;
            const m = cx.measureText(txt); const w = m.width+24; const h = fs+24;
            cv.width = w; cv.height = h;

            // Pillola semitrasparente
            cx.fillStyle = 'rgba(255, 255, 255, 0.85)';
            cx.beginPath(); cx.roundRect(0,0,w,h,12); cx.fill();
            cx.strokeStyle = '#c58f68'; cx.lineWidth=3; cx.stroke();

            cx.fillStyle = '#3e3a36'; cx.font = `bold ${fs}px Arial`;
            cx.textAlign = 'center'; cx.textBaseline = 'middle';
            cx.fillText(txt, w/2, h/2);

            const tex = new THREE.CanvasTexture(cv); tex.minFilter=THREE.LinearFilter;
            // depthTest: false -> Si vede SEMPRE, anche attraverso i muri
            const mat = new THREE.SpriteMaterial({ map:tex, depthTest:false, depthWrite:false });
            const sp = new THREE.Sprite(mat);
            sp.scale.set(0.0004*w, 0.0004*h, 1);
            sp.renderOrder = 9999; // Disegna per ultimo (sopra tutto)
            return sp;
        }

        function updateQuotes() {
            scene.remove(quoteGroup); 
            quoteGroup = new THREE.Group();
            
            if(!isQuotesMode) return;

            const lineMat = new THREE.LineBasicMaterial({ color: 0xc58f68, opacity:0.4, transparent:true, depthTest:false });
            scene.add(quoteGroup);

            cabinets.forEach(c => {
                // Box
                const b = new THREE.BoxHelper(c.mesh);
                b.material = lineMat; quoteGroup.add(b);

                // Etichette
                const lg = new THREE.Group();
                lg.position.copy(c.mesh.position);
                lg.rotation.y = c.mesh.rotation.y;

                const p = c.params;
                const lw = createLabel(`${p.width}`); lw.position.set(0, p.height/2+15, p.depth/2);
                const lh = createLabel(`${p.height}`); lh.position.set(-p.width/2-15, p.height/2, p.depth/2);
                const ld = createLabel(`${p.depth}`); ld.position.set(p.width/2+15, p.height/2, 0);

                lg.add(lw, lh, ld);
                quoteGroup.add(lg);
            });
        }

        // --- RANDOM FIXATO ---
        function generateRandomKitchen() {
            // 1. Pulizia totale
            cabinets.forEach(c => scene.remove(c.mesh));
            cabinets = [];
            select([]);
            scene.remove(quoteGroup);

            // 2. Definizione layout con posizioni calcolate (no sovrapposizioni)
            // Start X da sinistra
            let cx = -120; 

            // Frigo
            createCabinet({ id:crypto.randomUUID(), type:'fridge', color:'cream', width:60, height:215, depth:60, elevation:0, rotation:0, x:cx, z:0, isOpen:false });
            cx += 60; // Avanza larghezza frigo

            // Base 1 (Cassetti)
            createCabinet({ id:crypto.randomUUID(), type:'base', color:'cream', width:60, height:85, depth:60, elevation:0, rotation:0, x:cx + 30, z:0, isOpen:false }); // +30 perch√© la pos √® al centro (60/2)
            
            // Pensile sopra Base 1
            createCabinet({ id:crypto.randomUUID(), type:'wall', color:'cream', width:60, height:72, depth:35, elevation:145, rotation:0, x:cx + 30, z:-12, isOpen:false });
            cx += 60;

            // Lavello
            createCabinet({ id:crypto.randomUUID(), type:'sink', color:'cream', width:90, height:85, depth:60, elevation:0, rotation:0, x:cx + 45, z:0, isOpen:false });
            cx += 90;

            // Fuochi
            createCabinet({ id:crypto.randomUUID(), type:'cooktop', color:'cream', width:90, height:85, depth:60, elevation:0, rotation:0, x:cx + 45, z:0, isOpen:false });
            
            // Cappa/Pensile sopra fuochi
            createCabinet({ id:crypto.randomUUID(), type:'wall', color:'cream', width:90, height:72, depth:35, elevation:145, rotation:0, x:cx + 45, z:-12, isOpen:false });
            
            // 3. Update
            updateQuotes();
            showToast("Cucina Random Generata!");
        }

        // --- UTILS ---
        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg; t.style.opacity = 1;
            setTimeout(() => t.style.opacity = 0, 2000);
        }

        function saveToJSON() { 
            const d = cabinets.map(c=>c.params); 
            const b = new Blob([JSON.stringify(d)],{type:'application/json'}); 
            const a = document.createElement('a'); a.href=URL.createObjectURL(b); a.download='progetto.json'; a.click();
            showToast("Progetto salvato!");
        }
        
        function loadFromJSON() { 
            const i = document.createElement('input'); i.type='file'; 
            i.onchange = e => {
                const r = new FileReader(); 
                r.onload = v => {
                    cabinets.forEach(c=>scene.remove(c.mesh)); cabinets=[]; select([]);
                    JSON.parse(v.target.result).forEach(p=>createCabinet(p));
                    updateQuotes();
                    showToast("Progetto caricato!");
                };
                r.readAsText(e.target.files[0]);
            }; 
            i.click(); 
        }

        function takePhoto() { 
            renderer.render(scene, camera); 
            const a = document.createElement('a'); a.download='render.png'; 
            a.href = renderer.domElement.toDataURL('image/png'); a.click(); 
        }

        function updateTooltip() {
            const t = document.getElementById('measure-tooltip');
            if(selection.length===1) {
                const p = selection[0].params;
                const v = new THREE.Vector3(p.x, p.elevation+p.height, p.z);
                v.project(camera);
                const x = (v.x * .5 + .5) * window.innerWidth;
                const y = (-(v.y * .5 - .5) * window.innerHeight);
                t.style.left = x + 'px'; t.style.top = (y-30) + 'px';
                t.innerText = `${p.width}x${p.height}x${p.depth}`; t.style.opacity=1;
            } else t.style.opacity=0;
        }

        function setupGUI() {
            const apply = () => { selection.forEach(c=>Object.assign(c.params, props)); updateSelectionVisual(); };
            const f = gui.addFolder('Parametri');
            ctrls.c = f.add(props, 'color', {Crema:'cream', Rovere:'oak', Noce:'walnut', Sabbia:'sand'}).onChange(apply);
            ctrls.w = f.add(props, 'width', 1, 200).onChange(apply);
            f.add(props, 'deleteSel');
        }

        function onResize() {
            const asp = window.innerWidth / window.innerHeight;
            const d = window.innerWidth < 768 ? 260 : 200;
            camera.left = -d*asp; camera.right = d*asp; camera.top = d; camera.bottom = -d;
            camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); updateTooltip(); }
    </script>
</body>
</html>
