<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Smart Kitchen Architect</title>
    <style>
        /* UI MODERNA & ELEGANTE */
        body { margin: 0; overflow: hidden; font-family: 'Inter', 'Segoe UI', sans-serif; background: #2c3e50; }
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #2c3e50, #4ca1af); 
            color: white; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 9999;
            transition: opacity 0.6s ease-out;
        }
        .spinner { width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.3); border-top-color: #fff; border-radius: 50%; animation: spin 1s infinite linear; margin-bottom: 20px; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* PANNELLI FLOATING */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        .panel {
            pointer-events: auto; background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px); border-radius: 12px; padding: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15); border: 1px solid rgba(255,255,255,0.5);
            transition: transform 0.2s;
        }

        #controls-panel { position: absolute; top: 20px; left: 20px; width: 220px; }
        #price-panel { position: absolute; bottom: 20px; right: 20px; width: 200px; text-align: right; }
        
        h3 { margin: 0 0 10px 0; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; color: #555; border-bottom: 1px solid #ddd; padding-bottom: 5px; }
        p { margin: 5px 0; font-size: 13px; color: #333; display: flex; align-items: center; }
        
        .kbd { background: #eee; border: 1px solid #ccc; border-radius: 4px; padding: 2px 6px; font-size: 10px; font-weight: bold; margin-right: 8px; color: #555; box-shadow: 0 2px 0 #ccc; }

        .price-tag { font-size: 24px; font-weight: 800; color: #27ae60; margin: 0; }
        .price-label { font-size: 12px; color: #7f8c8d; text-transform: uppercase; }

        /* BUTTONS */
        #btn-photo {
            position: absolute; top: 20px; right: 20px; pointer-events: auto;
            background: #e67e22; color: white; border: none; padding: 10px 20px;
            border-radius: 30px; font-weight: bold; cursor: pointer;
            box-shadow: 0 4px 15px rgba(230, 126, 34, 0.4);
            transition: all 0.2s;
        }
        #btn-photo:hover { transform: scale(1.05); background: #d35400; }

        /* FLOATING LABEL (QUOTE) */
        #measure-label {
            position: absolute; background: #2c3e50; color: white;
            padding: 4px 8px; border-radius: 4px; font-size: 12px;
            pointer-events: none; opacity: 0; transition: opacity 0.2s;
            transform: translate(-50%, -100%); margin-top: -10px;
            white-space: nowrap; z-index: 1000;
        }
        #measure-label::after {
            content: ''; position: absolute; top: 100%; left: 50%; margin-left: -5px;
            border-width: 5px; border-style: solid; border-color: #2c3e50 transparent transparent transparent;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div style="font-weight: 300; letter-spacing: 2px;">LOADING STUDIO</div>
    </div>

    <div id="ui-layer">
        <div id="controls-panel" class="panel">
            <h3>Comandi Smart</h3>
            <p><span class="kbd">Doppio Click</span> Apri Anta</p>
            <p><span class="kbd">R</span> Ruota 90Â°</p>
            <p><span class="kbd">Shift+Arr</span> Muovi Veloce</p>
            <p><span class="kbd">Canc</span> Elimina</p>
        </div>

        <div id="price-panel" class="panel">
            <div class="price-label">Stima Progetto</div>
            <div id="total-price" class="price-tag">â‚¬ 0</div>
            <div style="font-size: 11px; color: #999; margin-top: 5px;">*Prezzi indicativi</div>
        </div>
        
        <div id="measure-label">60x85x60</div>
    </div>

    <button id="btn-photo">ðŸ“· Scatta Foto</button>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- VARIABILI CORE ---
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let cabinets = [];
        let selectedCabinet = null;
        let selectionBox;
        let floorMesh, wallMesh;
        
        // --- CONFIG & STATO ---
        const config = { step: 2, fastStep: 10, gridSize: 3000 };
        const props = {
            // Ambiente
            showFloor: true,
            wallColor: 'wall_white',
            
            // Modulo
            type: 'base', color: 'birch',
            width: 60, height: 85, depth: 60, elevation: 0,
            rotation: 0, isOpen: false,
            
            // Azioni
            addBase: () => smartSpawn('base'),
            addSink: () => smartSpawn('sink'),
            addCook: () => smartSpawn('cooktop'),
            addCorner: () => smartSpawn('corner'), // NEW
            addFridge: () => smartSpawn('fridge'), // NEW
            addTall: () => smartSpawn('tall'),
            addWall: () => smartSpawn('wall'),
            
            resetView: () => { controls.reset(); camera.position.set(500, 600, 500); camera.lookAt(0,0,0); },
            del: () => removeSelected()
        };

        // --- LIBRERIA MATERIALI ---
        const matLib = {
            birch: new THREE.MeshStandardMaterial({ color: 0xFADFB7, roughness: 0.6, name: 'Betulla' }),
            white_wood: new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.4, name: 'Bianco Puro' }),
            walnut: new THREE.MeshStandardMaterial({ color: 0x5D4037, roughness: 0.7, name: 'Noce Scuro' }),
            grey_matte: new THREE.MeshStandardMaterial({ color: 0x7f8c8d, roughness: 0.9, name: 'Grigio Opaco' }),
            navy: new THREE.MeshStandardMaterial({ color: 0x34495e, roughness: 0.5, name: 'Blu Notte' }),
            
            // Muri
            wall_white: new THREE.MeshStandardMaterial({ color: 0xf5f6fa }),
            wall_sage: new THREE.MeshStandardMaterial({ color: 0xa8e6cf }),
            wall_stone: new THREE.MeshStandardMaterial({ color: 0x95a5a6 }),

            // Tecnici
            top: new THREE.MeshStandardMaterial({ color: 0x2d3436, roughness: 0.6 }),
            steel: new THREE.MeshStandardMaterial({ color: 0xbdc3c7, metalness: 0.6, roughness: 0.2 }),
            black: new THREE.MeshStandardMaterial({ color: 0x111111 }),
            kick: new THREE.MeshStandardMaterial({ color: 0x2c3e50 }) // Zoccolo scuro standard
        };

        // Prezzi base per logica "Smart"
        const prices = { base: 150, sink: 250, cooktop: 300, tall: 400, wall: 100, corner: 350, fridge: 600 };

        // GUI
        const gui = new GUI({ title: 'Configuratore', width: 280 });
        const ctrls = {};

        init();

        function init() {
            try {
                // 1. SCENA
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xdce4eb);
                scene.fog = new THREE.Fog(0xdce4eb, 900, 3000);

                // 2. CAMERA ISO
                const aspect = window.innerWidth / window.innerHeight;
                const d = 600;
                camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 1, 5000);
                camera.position.set(500, 600, 500); 
                camera.lookAt(0,0,0);

                // 3. RENDERER
                renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(renderer.domElement);

                // 4. LUCI
                const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
                scene.add(hemiLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
                dirLight.position.set(400, 800, 600);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.set(2048, 2048);
                scene.add(dirLight);

                // 5. AMBIENTE
                createEnvironment();

                // 6. HELPERS
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                
                // Box selezione
                selectionBox = new THREE.BoxHelper(new THREE.Mesh(), 0xe67e22);
                selectionBox.visible = false;
                scene.add(selectionBox);

                setupGUI();

                // 7. EVENTI
                window.addEventListener('resize', onResize);
                window.addEventListener('keydown', onKeyDown);
                renderer.domElement.addEventListener('pointerdown', onPointerDown);
                renderer.domElement.addEventListener('dblclick', onDoubleClick); // Smart Feature
                document.getElementById('btn-photo').addEventListener('click', takePhoto);

                // Rimuovi loader
                const l = document.getElementById('loader');
                l.style.opacity = 0;
                setTimeout(() => l.remove(), 600);

                // Init
                smartSpawn('base');

                animate();
            } catch (e) {
                alert("Errore Inizializzazione: " + e.message);
            }
        }

        function createEnvironment() {
            // Pavimento
            const floorGeo = new THREE.PlaneGeometry(config.gridSize, config.gridSize);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0xe0e0e0, roughness: 0.8 });
            floorMesh = new THREE.Mesh(floorGeo, floorMat);
            floorMesh.rotation.x = -Math.PI / 2;
            floorMesh.position.y = -0.5;
            floorMesh.receiveShadow = true;
            scene.add(floorMesh);

            // Griglia
            const grid = new THREE.GridHelper(config.gridSize, 60, 0xbdc3c7, 0xffffff);
            grid.material.transparent = true;
            grid.material.opacity = 0.3;
            scene.add(grid);

            // Muro
            const wallGeo = new THREE.BoxGeometry(config.gridSize, 400, 10);
            wallMesh = new THREE.Mesh(wallGeo, matLib.wall_white);
            wallMesh.position.set(0, 200, -150);
            wallMesh.receiveShadow = true;
            scene.add(wallMesh);
        }

        // --- SMART SPAWN LOGIC ---
        function smartSpawn(type) {
            const defs = { 
                base:[85,0,60], sink:[85,0,60], cooktop:[85,0,60], 
                tall:[215,0,60], wall:[72,145,35], corner:[85,0,90], fridge:[215,0,60] 
            };
            
            const [h, y, d] = defs[type];
            const w = (type === 'corner') ? 90 : 60; 

            let tx = 0, tz = 0, trot = 0;
            let lastColor = 'birch';

            if(cabinets.length > 0) {
                // Prendi ultimo cabinet
                const last = selectedCabinet || cabinets[cabinets.length - 1];
                const lp = last.params;
                lastColor = lp.color;

                const rad = lp.rotation * (Math.PI/180);
                
                // Distanza da percorrere: MetÃ  del precedente + MetÃ  del nuovo
                let dist = (lp.width/2) + (w/2);
                
                // Se il precedente era un angolo, la logica cambia
                if (lp.type === 'corner') {
                    // Se l'angolo Ã¨ 90x90, l'uscita Ã¨ ruotata di 90 gradi rispetto all'ingresso
                    // Per semplicitÃ : se aggiungo dopo un angolo, ruoto di 90 gradi e mi sposto
                    trot = lp.rotation - 90; // Ruota a DX
                    dist = (lp.width/2) + (w/2) - 30; // Aggiustamento offset angolo
                    
                    // Calcolo nuova posizione "uscendo" dall'angolo
                    const radNew = trot * (Math.PI/180);
                    tx = lp.x + Math.cos(rad) * 30 + Math.cos(radNew) * (w/2);
                    tz = lp.z + Math.sin(rad) * 30 + Math.sin(radNew) * (w/2);
                    
                } else {
                    // Lineare
                    trot = lp.rotation;
                    tx = lp.x + Math.cos(rad) * dist;
                    tz = lp.z + Math.sin(rad) * dist;
                }
            }

            const params = {
                id: crypto.randomUUID(),
                type, color: lastColor,
                width: w, height: h, depth: d, elevation: y,
                rotation: trot, x: tx, z: tz, isOpen: false
            };
            updateCabinet(params, true);
        }

        // --- GENERATORE GEOMETRIE (GARBAGE COLLECTED) ---
        function createCabinetMesh(p) {
            const group = new THREE.Group();
            const toeH = (p.type === 'wall' || p.type === 'fridge') ? 0 : 10;
            const topH = (['base','sink','cooktop','corner'].includes(p.type)) ? 4 : 0;
            const bodyH = p.height - toeH - topH;
            const mat = (p.type === 'fridge') ? matLib.steel : (matLib[p.color] || matLib.birch);

            // 1. CARCASSA
            if (p.type === 'corner') {
                // Forma a L (2 box uniti)
                const size = p.width; // 90x90
                const thick = 60; // ProfonditÃ  standard
                
                // Parte principale
                const b1 = new THREE.Mesh(new THREE.BoxGeometry(size, bodyH, thick), mat);
                b1.position.set(0, toeH+bodyH/2, (size-thick)/2);
                
                // Parte laterale (L)
                const b2 = new THREE.Mesh(new THREE.BoxGeometry(size-thick, bodyH, thick), mat);
                b2.position.set(-(thick)/2 - (size-thick)/2, toeH+bodyH/2, -(thick)/2);
                b2.rotation.y = Math.PI/2;
                
                b1.castShadow = true; b2.castShadow = true;
                group.add(b1, b2);
                
                // Top Angolo
                const t1 = new THREE.Mesh(new THREE.BoxGeometry(size, topH, thick+2), matLib.top);
                t1.position.set(0, toeH+bodyH+topH/2, (size-thick)/2 + 1);
                
                const t2 = new THREE.Mesh(new THREE.BoxGeometry(size-thick-2, topH, thick+2), matLib.top);
                t2.position.set(-(thick)/2 - (size-thick)/2 + 1, toeH+bodyH+topH/2, -(thick)/2 + 1);
                t2.rotation.y = Math.PI/2;
                group.add(t1, t2);

            } else {
                // BOX STANDARD
                const box = new THREE.Mesh(new THREE.BoxGeometry(p.width, bodyH, p.depth), mat);
                box.position.y = toeH + bodyH/2;
                box.castShadow = true;
                group.add(box);

                // TOP
                if (topH > 0) {
                    const top = new THREE.Mesh(new THREE.BoxGeometry(p.width, topH, p.depth+2), matLib.top);
                    top.position.set(0, toeH+bodyH+topH/2, 1);
                    top.castShadow = true;
                    group.add(top);
                }
            }

            // 2. DETTAGLI SPECIALI
            if(p.type === 'sink') {
                const basin = new THREE.Mesh(new THREE.BoxGeometry(p.width-15, 15, p.depth-15), matLib.steel);
                basin.position.set(0, toeH+bodyH+2, 1);
                const inner = new THREE.Mesh(new THREE.BoxGeometry(p.width-17, 15.2, p.depth-17), matLib.black);
                inner.position.set(0, toeH+bodyH+2.1, 1);
                const tap = new THREE.Mesh(new THREE.CylinderGeometry(1,1.5,20), matLib.steel);
                tap.position.set(0, toeH+bodyH+10, -15);
                tap.rotation.x = 0.2;
                group.add(basin, inner, tap);
            }
            else if(p.type === 'cooktop') {
                const plate = new THREE.Mesh(new THREE.BoxGeometry(p.width-10, 1, p.depth-10), matLib.black);
                plate.position.set(0, toeH+bodyH+topH+0.5, 1);
                group.add(plate);
                const fire = new THREE.Mesh(new THREE.CylinderGeometry(3,3,1), matLib.fire);
                fire.position.set(0, toeH+bodyH+topH+1, 0);
                group.add(fire);
            }
            else if(p.type === 'fridge') {
                // Divisoria porte frigo
                const divY = bodyH * 0.4; // Freezer in basso
                // Maniglie
                const h1 = new THREE.Mesh(new THREE.BoxGeometry(2, 30, 2), matLib.black);
                h1.position.set(p.width/2 - 5, toeH + bodyH/2 + 20, p.depth/2 + 2);
                group.add(h1);
            }

            // 3. ANTE
            if (p.type !== 'corner' && p.type !== 'fridge') {
                const isDouble = p.width >= 60;
                const dW = isDouble ? (p.width/2)-0.2 : p.width-0.4;
                const dH = bodyH - 0.4;
                const dThick = 2;
                
                const dGrp = new THREE.Group();
                dGrp.position.set(0, toeH+bodyH/2, p.depth/2 + dThick/2);

                if (isDouble) {
                    const d1 = makeDoor(dW, dH, mat, -1); d1.position.x = -p.width/4;
                    const d2 = makeDoor(dW, dH, mat, 1); d2.position.x = p.width/4;
                    if(p.isOpen) { d1.rotation.y = 1.5; d2.rotation.y = -1.5; }
                    dGrp.add(d1, d2);
                } else {
                    const d1 = makeDoor(dW, dH, mat, 1);
                    if(p.isOpen) { d1.rotation.y = 1.5; d1.position.x += dW/2; }
                    dGrp.add(d1);
                }
                group.add(dGrp);
            }
            
            // Anta Angolo (Semplificata: una diagonale o due fisse)
            if (p.type === 'corner') {
                const d = makeDoor(40, bodyH-0.4, mat, 1);
                d.position.set(10, toeH+bodyH/2, 60/2 + 1); // Posizione approssimata lato
                if(p.isOpen) d.rotation.y = 1.5;
                group.add(d);
            }

            // 4. ZOCCOLO
            if (toeH > 0) {
                const kick = new THREE.Mesh(new THREE.BoxGeometry(p.width-2, toeH, p.depth-5), matLib.kick);
                kick.position.set(0, toeH/2, -3);
                group.add(kick);
            }

            return group;
        }

        function makeDoor(w, h, mat, handleDir) {
            const g = new THREE.Group();
            const p = new THREE.Mesh(new THREE.BoxGeometry(w, h, 2), mat);
            p.castShadow = true;
            g.add(p);
            // Maniglia
            const han = new THREE.Mesh(new THREE.BoxGeometry(1, 15, 1), matLib.black);
            han.position.set((handleDir>0 ? -w/2+4 : w/2-4), 5, 2);
            g.add(han);
            return g;
        }

        // --- UPDATE & CLEANUP ---
        function updateCabinet(params, isNew = false) {
            if (!isNew) {
                const old = cabinets.find(c => c.params.id === params.id);
                if (old) {
                    scene.remove(old.mesh);
                    // Garbage Collection manuale per pulizia memoria
                    old.mesh.traverse(o => {
                        if(o.geometry) o.geometry.dispose();
                        // Non facciamo dispose dei materiali perchÃ© sono condivisi (matLib)
                    });
                    cabinets = cabinets.filter(c => c.params.id !== params.id);
                }
            }

            const mesh = createCabinetMesh(params);
            mesh.position.set(params.x, params.elevation, params.z);
            mesh.rotation.y = params.rotation * (Math.PI / 180);
            mesh.userData = { isCab: true, id: params.id };

            scene.add(mesh);
            const obj = { mesh, params };
            cabinets.push(obj);

            calculateTotal();
            if (isNew || (selectedCabinet && selectedCabinet.params.id === params.id)) select(obj);
        }

        // --- INTERAZIONE ---
        function onPointerDown(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(scene.children, true);
            
            let found = null;
            for(let h of hits) {
                let p = h.object;
                while(p) { if(p.userData?.isCab) { found=p; break; } p = p.parent; }
                if(found) break;
            }

            if(found) select(cabinets.find(c => c.params.id === found.userData.id));
            else if(hits.length===0 || hits[0].object === floorMesh) select(null);
        }

        // SMART: Doppio click apre le porte
        function onDoubleClick(e) {
            if(selectedCabinet) {
                selectedCabinet.params.isOpen = !selectedCabinet.params.isOpen;
                props.isOpen = selectedCabinet.params.isOpen;
                ctrls.opn.updateDisplay();
                updateCabinet(selectedCabinet.params);
            }
        }

        function select(obj) {
            selectedCabinet = obj;
            const label = document.getElementById('measure-label');

            if(!obj) {
                selectionBox.visible = false;
                label.style.opacity = 0;
                return;
            }

            selectionBox.setFromObject(obj.mesh);
            selectionBox.visible = true;

            // Sync GUI (senza loop)
            const p = obj.params;
            Object.assign(props, {
                type: p.type, color: p.color, width: p.width, height: p.height,
                elevation: p.elevation, rotation: p.rotation, isOpen: p.isOpen
            });
            for(let k in ctrls) ctrls[k].updateDisplay();

            // Aggiorna etichetta 3D
            updateLabelPos();
        }

        function updateLabelPos() {
            if(!selectedCabinet) return;
            const p = selectedCabinet.params;
            const label = document.getElementById('measure-label');
            
            // Proietta posizione 3D in 2D
            const vec = new THREE.Vector3(p.x, p.elevation + p.height + 20, p.z);
            vec.project(camera);
            const x = (vec.x * .5 + .5) * window.innerWidth;
            const y = (-(vec.y * .5) + .5) * window.innerHeight;

            label.style.left = x + 'px';
            label.style.top = y + 'px';
            label.innerText = `${p.width}x${p.height}x${p.depth} cm`;
            label.style.opacity = 1;
        }

        function onKeyDown(e) {
            if (!selectedCabinet) return;
            const step = e.shiftKey ? config.fastStep : config.step;
            let p = selectedCabinet.params;
            let changed = false;

            if(e.key==='ArrowLeft') { p.x -= step; changed=true; }
            if(e.key==='ArrowRight') { p.x += step; changed=true; }
            if(e.key==='ArrowUp') { p.z -= step; changed=true; }
            if(e.key==='ArrowDown') { p.z += step; changed=true; }
            if(e.key==='r' || e.key==='R') { p.rotation = (p.rotation+90)%360; changed=true; }
            if(e.key==='Delete') { removeSelected(); changed=false; }

            if(changed) {
                selectedCabinet.mesh.position.set(p.x, p.elevation, p.z);
                selectedCabinet.mesh.rotation.y = p.rotation * (Math.PI/180);
                selectionBox.update();
                updateLabelPos();
                props.rotation = p.rotation; ctrls.rot.updateDisplay();
            }
        }

        function removeSelected() {
            if(!selectedCabinet) return;
            scene.remove(selectedCabinet.mesh);
            cabinets = cabinets.filter(c => c !== selectedCabinet);
            select(null);
            calculateTotal();
        }

        function calculateTotal() {
            let total = 0;
            cabinets.forEach(c => total += (prices[c.params.type] || 100));
            document.getElementById('total-price').innerText = "â‚¬ " + total;
        }

        function takePhoto() {
            renderer.render(scene, camera);
            const a = document.createElement('a');
            a.download = 'progetto_cucina.png';
            a.href = renderer.domElement.toDataURL('image/png');
            a.click();
        }

        // --- GUI SETUP ---
        function setupGUI() {
            const apply = () => { if(selectedCabinet) { 
                Object.assign(selectedCabinet.params, props); 
                updateCabinet(selectedCabinet.params); 
            }};

            const fEnv = gui.addFolder('ðŸ  Ambiente');
            fEnv.add(props, 'showFloor').name('Pavimento').onChange(v=>floorMesh.visible=v);
            fEnv.add(props, 'wallColor', Object.keys(matLib).filter(k=>k.startsWith('wall'))).name('Colore Muro').onChange(v => wallMesh.material = matLib[v]);
            fEnv.add(props, 'resetView').name('Centra Vista');

            const fAdd = gui.addFolder('âž• Moduli');
            fAdd.add(props, 'addBase').name('Base');
            fAdd.add(props, 'addCorner').name('Angolo');
            fAdd.add(props, 'addSink').name('Lavandino');
            fAdd.add(props, 'addCook').name('Cottura');
            fAdd.add(props, 'addTall').name('Colonna');
            fAdd.add(props, 'addFridge').name('Frigo');
            fAdd.add(props, 'addWall').name('Pensile');

            const fEdit = gui.addFolder('ðŸ”§ Modifica');
            ctrls.type = fEdit.add(props, 'type', ['base','sink','cooktop','tall','wall','corner','fridge']).name('Modello').onChange(apply);
            ctrls.color = fEdit.add(props, 'color', ['birch','white_wood','walnut','grey_matte','navy']).name('Colore').onChange(apply);
            ctrls.w = fEdit.add(props, 'width', 15, 120, 5).onChange(apply);
            ctrls.h = fEdit.add(props, 'height', 15, 250, 5).onChange(apply);
            ctrls.elv = fEdit.add(props, 'elevation', 0, 250, 5).onChange(apply);
            ctrls.rot = fEdit.add(props, 'rotation', 0, 360, 15).onChange(apply);
            ctrls.opn = fEdit.add(props, 'isOpen').name('Ante Aperte').onChange(apply);
            fEdit.add(props, 'del').name('Elimina');

            fAdd.open();
        }

        function onResize() {
            const asp = window.innerWidth/window.innerHeight;
            const d = 600;
            camera.left = -d*asp; camera.right = d*asp;
            camera.top = d; camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(selectedCabinet) updateLabelPos();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            if(selectedCabinet) updateLabelPos();
        }
    </script>
</body>
</html>
