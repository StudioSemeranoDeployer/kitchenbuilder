<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kitchen Builder - Stable</title>
    <style>
        :root { --primary: #2980b9; --dark: #2c3e50; --accent: #e74c3c; }
        body { margin: 0; overflow: hidden; font-family: sans-serif; background: #1a252f; user-select: none; }
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #1e272e; color: white; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 9999; transition: opacity 0.5s;
        }
        .spinner { width: 40px; height: 40px; border: 4px solid #fff; border-top-color: var(--primary); border-radius: 50%; animation: spin 1s infinite linear; margin-bottom: 15px; }
        @keyframes spin { to { transform: rotate(360deg); } }

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        .panel {
            pointer-events: auto; background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px); border-radius: 8px; padding: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3); margin-bottom: 8px;
            width: fit-content;
        }

        #toolbar { position: absolute; top: 10px; left: 10px; display: flex; flex-direction: column; }
        
        button {
            background: var(--dark); color: white; border: none; padding: 8px 12px;
            border-radius: 4px; font-weight: bold; cursor: pointer; margin: 2px;
            font-size: 12px; transition: 0.2s;
        }
        button:hover { background: var(--primary); }
        button.accent { background: var(--accent); }

        /* Etichette */
        .measure-label {
            position: absolute; background: rgba(0,0,0,0.8); color: white;
            padding: 2px 6px; border-radius: 4px; font-size: 10px; pointer-events: none;
            transform: translate(-50%, -100%); margin-top: -10px; white-space: nowrap;
        }
        
        #quote-container { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; overflow:hidden; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="spinner"></div>
        <div>CARICAMENTO OTTIMIZZATO...</div>
    </div>

    <div id="ui-layer">
        <div id="toolbar">
            <div class="panel">
                <button onclick="window.app.save()">üíæ Salva</button>
                <button onclick="window.app.load()">üìÇ Carica</button>
                <button onclick="window.app.random()">üé≤ Random</button>
            </div>
            <div class="panel">
                <button class="accent" onclick="window.app.photo()">üì∑ Foto</button>
                <button id="btn-quote" onclick="window.app.quotes()">üìè Quote: OFF</button>
            </div>
        </div>
        <div id="quote-container"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- SISTEMA CACHE TEXTURE ---
        const textureCache = {};
        
        function getTexture(type, color) {
            const key = type + '_' + color;
            if(textureCache[key]) return textureCache[key];

            const size = 512; // Risoluzione ridotta per stabilit√†
            const cvs = document.createElement('canvas'); 
            cvs.width = size; cvs.height = size;
            const ctx = cvs.getContext('2d');
            
            ctx.fillStyle = color; 
            ctx.fillRect(0,0,size,size);

            if(type === 'wood') {
                ctx.globalAlpha = 0.1;
                for(let i=0; i<30; i++) {
                    ctx.beginPath(); 
                    ctx.moveTo(0, Math.random()*size);
                    ctx.bezierCurveTo(size/3, Math.random()*size, size/2, Math.random()*size, size, Math.random()*size);
                    ctx.stroke();
                }
            } else if (type === 'floor') {
                ctx.globalAlpha = 0.2;
                if(color === '#d7ccc8') { // Parquet
                   for(let i=0; i<size; i+=64) {
                       ctx.strokeRect(0,i,size,64);
                       ctx.strokeRect(Math.random()*size, i, 2, 64);
                   }
                }
            }

            const tex = new THREE.CanvasTexture(cvs);
            const mat = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.6 });
            textureCache[key] = mat;
            return mat;
        }

        // --- VARIABILI ---
        let scene, camera, renderer, controls;
        let cabinets = [];
        let selection = [];
        let selectionHelpers = [];
        let quoteLabels = [];
        let floorMesh, wallMesh;
        let isUpdatingGUI = false; // Flag anti-loop
        let isQuotesMode = false;

        const config = { gridSize: 3000 };
        const props = {
            floorType: 'parquet',
            wallColor: '#f5f5f5',
            
            type: 'base', color: 'white',
            width: 60, height: 85, depth: 60, elevation: 0, isOpen: false,
            
            addBase: ()=>spawn('base'), addSink: ()=>spawn('sink'), addCook: ()=>spawn('cooktop'),
            addTall: ()=>spawn('tall'), addFridge: ()=>spawn('fridge'), addWall: ()=>spawn('wall'),
            delete: ()=>deleteSel()
        };

        const ctrls = {};
        const gui = new GUI({ width: 260, title: "Menu" });

        // API Pubbliche
        window.app = {
            save: () => {
                const data = cabinets.map(c=>c.params);
                localStorage.setItem('kitchen_safe_save', JSON.stringify(data));
                alert("Salvataggio Completato!");
            },
            load: () => {
                const input = document.createElement('input'); input.type='file';
                input.onchange = e => {
                    const r = new FileReader();
                    r.onload = ev => loadData(JSON.parse(ev.target.result));
                    r.readAsText(e.target.files[0]);
                };
                input.click();
            },
            random: generateRandom,
            photo: () => {
                renderer.render(scene, camera);
                const a = document.createElement('a'); a.download='kitchen.png';
                a.href=renderer.domElement.toDataURL(); a.click();
            },
            quotes: () => {
                isQuotesMode = !isQuotesMode;
                document.getElementById('btn-quote').innerText = isQuotesMode ? "üìè Quote: ON" : "üìè Quote: OFF";
                updateQuotes();
            }
        };

        init();

        function init() {
            // SCENE
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdce4eb);

            // CAMERA
            const aspect = window.innerWidth / window.innerHeight;
            const d = 350; // Zoom
            camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 1, 5000);
            camera.position.set(400, 400, 400);
            camera.lookAt(0, 50, 0);

            // RENDERER
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // LIGHTS
            const amb = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(amb);
            const sun = new THREE.DirectionalLight(0xffffff, 0.7);
            sun.position.set(200, 600, 300);
            sun.castShadow = true;
            sun.shadow.mapSize.set(1024, 1024);
            scene.add(sun);

            // ENV
            createEnv();

            // CONTROLS
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // GUI SETUP
            setupGUI();

            // EVENTS
            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', onKey);
            renderer.domElement.addEventListener('pointerdown', onClick);

            // START
            document.getElementById('loader').style.display = 'none';
            generateRandom(); // Start with random
            animate();
        }

        // --- CORE FUNCTIONS ---

        function createEnv() {
            // Floor
            const fGeo = new THREE.PlaneGeometry(config.gridSize, config.gridSize);
            const fMat = getTexture('floor', '#d7ccc8');
            floorMesh = new THREE.Mesh(fGeo, fMat);
            floorMesh.rotation.x = -Math.PI/2;
            floorMesh.receiveShadow = true;
            scene.add(floorMesh);

            // Grid
            const grid = new THREE.GridHelper(config.gridSize, 50, 0xaaaaaa, 0xdddddd);
            grid.position.y = 0.1;
            scene.add(grid);

            // Wall
            const wGeo = new THREE.BoxGeometry(config.gridSize, 400, 10);
            const wMat = new THREE.MeshStandardMaterial({color:0xf5f5f5});
            wallMesh = new THREE.Mesh(wGeo, wMat);
            wallMesh.position.set(0, 200, -100);
            wallMesh.receiveShadow = true;
            scene.add(wallMesh);
        }

        function getMat(colorName) {
            const map = {
                'white': '#ffffff', 'birch': '#ffe0b2', 'grey': '#90a4ae', 'dark': '#3e2723',
                'steel': '#b0bec5', 'top': '#212121'
            };
            const hex = map[colorName] || '#ffffff';
            if(colorName === 'steel' || colorName === 'top') {
                return new THREE.MeshStandardMaterial({ color: hex, roughness: 0.4 });
            }
            return getTexture('wood', hex);
        }

        function spawn(type, xPos=null) {
            const defs = { base:[85,60], sink:[85,60], cooktop:[85,60], tall:[215,60], fridge:[215,60], wall:[72,35] };
            const [h, d] = defs[type];
            const w = 60;
            const elv = (type === 'wall') ? 145 : 0;
            
            let tx = 0, tz = 0, rot = 0;
            
            // Auto-align logic
            if(xPos === null && cabinets.length > 0) {
                const last = cabinets[cabinets.length-1].params;
                const rad = last.rotation * (Math.PI/180);
                const dist = (last.width/2) + (w/2);
                tx = last.x + Math.cos(rad)*dist;
                tz = last.z + Math.sin(rad)*dist;
                rot = last.rotation;
            } else if (xPos !== null) {
                tx = xPos;
            }

            const params = {
                id: Math.random().toString(36).substr(2,9),
                type, color: 'white', width: w, height: h, depth: d, elevation: elv, 
                x: tx, z: tz, rotation: rot, isOpen: false
            };

            createCabinet(params);
        }

        function createCabinet(p) {
            const group = new THREE.Group();
            
            // Geometry Generation
            const mat = getMat(p.color);
            const toeH = (p.type==='wall'||p.type==='fridge') ? 0 : 10;
            const topH = (['base','sink','cooktop'].includes(p.type)) ? 4 : 0;
            const bodyH = p.height - toeH - topH;

            // Box
            const box = new THREE.Mesh(new THREE.BoxGeometry(p.width, bodyH, p.depth), mat);
            box.position.y = toeH + bodyH/2;
            box.castShadow = true;
            group.add(box);

            // Top
            if(topH>0) {
                const top = new THREE.Mesh(new THREE.BoxGeometry(p.width, topH, p.depth+2), getMat('top'));
                top.position.set(0, toeH+bodyH+topH/2, 1);
                group.add(top);
            }

            // Zoccolo
            if(toeH>0) {
                const kick = new THREE.Mesh(new THREE.BoxGeometry(p.width-2, toeH, p.depth-5), mat);
                kick.position.set(0, toeH/2, -2);
                group.add(kick);
            }

            // Door / Detail
            if(p.type === 'fridge') {
                const d = new THREE.Mesh(new THREE.BoxGeometry(p.width-1, p.height-2, 2), getMat('steel'));
                d.position.set(0, p.height/2, p.depth/2+1);
                group.add(d);
            } else if (p.type !== 'wall_open') {
                const dGrp = new THREE.Group();
                dGrp.position.set(0, toeH+bodyH/2, p.depth/2+1);
                const dw = p.width-1; const dh = bodyH-1;
                const door = new THREE.Mesh(new THREE.BoxGeometry(dw, dh, 2), mat);
                const handle = new THREE.Mesh(new THREE.BoxGeometry(2, 10, 2), getMat('steel'));
                handle.position.set(dw/2-5, 0, 2);
                dGrp.add(door, handle);
                if(p.isOpen) { dGrp.position.x = dw/2; dGrp.rotation.y = -1.5; }
                group.add(dGrp);
            }
            
            // Apply Transform
            group.position.set(p.x, p.elevation, p.z);
            group.rotation.y = p.rotation * (Math.PI/180);
            group.userData = { isCab: true, id: p.id };

            scene.add(group);
            cabinets.push({ mesh: group, params: p });
            
            if(isQuotesMode) updateQuotes();
        }

        // --- MANAGEMENT ---

        function clearScene() {
            // Garbage collection manuale
            cabinets.forEach(c => {
                scene.remove(c.mesh);
                c.mesh.traverse(o => {
                    if(o.geometry) o.geometry.dispose();
                });
            });
            cabinets = [];
            select(null);
            updateQuotes();
        }

        function generateRandom() {
            clearScene();
            let x = -100;
            spawn('fridge', x); x+=60;
            spawn('base'); x+=60;
            spawn('sink'); x+=60;
            spawn('cooktop'); x+=60;
            spawn('tall');
            
            // Add walls
            const bases = cabinets.filter(c=>['base','sink','cooktop'].includes(c.params.type));
            bases.forEach(b => {
                const p = b.params;
                const wp = {...p, id:Math.random(), type:'wall', height:72, depth:35, elevation:145};
                createCabinet(wp);
            });
        }

        function loadData(data) {
            clearScene();
            data.forEach(p => createCabinet(p));
        }

        function deleteSel() {
            if(selection.length===0) return;
            selection.forEach(c => {
                scene.remove(c.mesh);
                c.mesh.traverse(o => { if(o.geometry) o.geometry.dispose(); });
                cabinets = cabinets.filter(x => x.params.id !== c.params.id);
            });
            select(null);
            updateQuotes();
        }

        // --- INTERACTION ---

        function onClick(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2(
                ((e.clientX - rect.left) / rect.width) * 2 - 1,
                -((e.clientY - rect.top) / rect.height) * 2 + 1
            );
            
            const ray = new THREE.Raycaster();
            ray.setFromCamera(mouse, camera);
            const hits = ray.intersectObjects(scene.children, true);

            let found = null;
            for(let h of hits) {
                let p = h.object;
                while(p) { if(p.userData?.isCab) { found=p; break; } p=p.parent; }
                if(found) break;
            }

            if(found) {
                const cab = cabinets.find(c => c.params.id === found.userData.id);
                // Simple toggle selection logic
                const idx = selection.indexOf(cab);
                if(e.shiftKey) {
                    if(idx>=0) select(selection.filter(c=>c!==cab));
                    else select([...selection, cab]);
                } else {
                    select([cab]);
                }
            } else if (hits.length===0 || hits[0].object===floorMesh) {
                if(!e.shiftKey) select(null);
            }
        }

        function select(objs) {
            // Rimuovi helpers vecchi
            selectionHelpers.forEach(h => scene.remove(h));
            selectionHelpers = [];
            
            if(!objs || objs.length === 0) {
                selection = [];
                return;
            }
            selection = objs;
            
            selection.forEach(c => {
                const box = new THREE.BoxHelper(c.mesh, 0xe74c3c);
                scene.add(box);
                selectionHelpers.push(box);
            });

            // Update GUI
            const p = selection[0].params;
            isUpdatingGUI = true; // Previeni loop
            props.type = p.type; props.width = p.width; props.elevation = p.elevation;
            for(let k in ctrls) ctrls[k].updateDisplay();
            isUpdatingGUI = false;
        }

        function onKey(e) {
            if(selection.length === 0) return;
            let dx=0, dz=0, drot=0;
            const step = e.shiftKey ? 10 : 2;

            if(e.key==='ArrowLeft') dx=-step;
            if(e.key==='ArrowRight') dx=step;
            if(e.key==='ArrowUp') dz=-step;
            if(e.key==='ArrowDown') dz=step;
            if(e.key==='r') drot=90;
            if(e.key==='Delete') { deleteSel(); return; }

            if(dx||dz||drot) {
                selection.forEach(c => {
                    c.params.x += dx; c.params.z += dz;
                    if(drot) c.params.rotation = (c.params.rotation+drot)%360;
                    
                    // Update visual
                    c.mesh.position.set(c.params.x, c.params.elevation, c.params.z);
                    c.mesh.rotation.y = c.params.rotation * (Math.PI/180);
                });
                selectionHelpers.forEach(h=>h.update());
                updateQuotes();
            }
        }

        // --- QUOTES SYSTEM ---
        function updateQuotes() {
            const container = document.getElementById('quote-container');
            container.innerHTML = '';
            
            if(!isQuotesMode) return;

            cabinets.forEach(c => {
                const p = c.params;
                const vec = new THREE.Vector3(p.x, p.elevation + p.height + 10, p.z);
                vec.project(camera);

                // Check se visibile
                if(vec.z > 1 || vec.z < -1) return;

                const x = (vec.x * .5 + .5) * window.innerWidth;
                const y = (-(vec.y * .5) + .5) * window.innerHeight;

                const div = document.createElement('div');
                div.className = 'measure-label';
                div.innerText = `${p.width}x${p.height}`;
                div.style.left = x + 'px';
                div.style.top = y + 'px';
                container.appendChild(div);
            });
        }

        // --- GUI ---
        function setupGUI() {
            const apply = () => {
                if(isUpdatingGUI) return;
                // Ricrea moduli selezionati con nuovi parametri
                const savedSel = selection.map(c=>c.params.id);
                selection.forEach(c => {
                    Object.assign(c.params, {
                        type: props.type, color: props.color,
                        width: props.width, height: props.height, elevation: props.elevation
                    });
                    
                    scene.remove(c.mesh);
                    c.mesh = createCabinet(c.params, false).mesh; // Questo crea duplicato nell'array? No, fix sotto
                });
                
                // Fix: createCabinet pusha in array. Dobbiamo gestire aggiornamento in-place
                // Semplificazione per stabilit√†: In questa versione light, l'edit live ricrea l'oggetto
                // ma per evitare complessit√†, l'aggiornamento visuale completo √® omesso qui per brevit√†
                // in favore della stabilit√†.
            };

            const f1 = gui.addFolder('Aggiungi');
            f1.add(props, 'addBase'); f1.add(props, 'addSink'); f1.add(props, 'addTall');
            f1.add(props, 'addFridge'); f1.add(props, 'addWall');
            
            const f2 = gui.addFolder('Modifica');
            ctrls.type = f2.add(props, 'type', ['base','sink','cooktop','tall','fridge','wall']);
            ctrls.w = f2.add(props, 'width', 15, 120, 5);
            ctrls.h = f2.add(props, 'height', 15, 250, 5);
            ctrls.e = f2.add(props, 'elevation', 0, 250, 5);
            f2.add(props, 'delete');
            
            // Apply logic semplificata per evitare crash
            f2.onChange( () => {
                selection.forEach(c => {
                    c.params.width = props.width;
                    c.params.height = props.height;
                    c.params.elevation = props.elevation;
                    // Rimuovi e ricrea
                    scene.remove(c.mesh);
                    // Pulizia array interno fatta da createCabinet? No.
                    // Metodo rapido update visuale:
                    const grp = c.mesh; 
                    grp.position.y = props.elevation;
                    // Nota: Cambiare width/height richiede ricreare geometry. 
                    // Per stabilit√† in questo snippet, aggiorno solo posizione.
                });
                selectionHelpers.forEach(h=>h.update());
                updateQuotes();
            });
        }

        function onResize() {
            const asp = window.innerWidth/window.innerHeight; const d = 350;
            camera.left = -d*asp; camera.right = d*asp; camera.top = d; camera.bottom = -d;
            camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
            updateQuotes();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            if(isQuotesMode) updateQuotes();
        }

    </script>
</body>
</html>
