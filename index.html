<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Kitchen Builder - Rotation & Colors</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #2c3e50; }
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #2c3e50; color: white; display: flex; 
            justify-content: center; align-items: center; font-size: 20px; z-index: 9999;
        }

        #ui-container {
            position: absolute; top: 10px; left: 10px; pointer-events: none;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px; border-radius: 8px; margin-bottom: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            max-width: 260px; pointer-events: auto;
        }

        h3 { margin: 0 0 5px 0; color: #333; }
        p { margin: 0; font-size: 13px; color: #666; }
        
        .key {
            display: inline-block; background: #eee; border: 1px solid #ccc;
            border-radius: 4px; padding: 2px 6px; font-size: 11px; font-weight: bold;
        }

        #btn-photo {
            position: absolute; top: 20px; right: 20px;
            background: #e67e22; color: white; border: none;
            padding: 10px 20px; border-radius: 6px; cursor: pointer;
            font-weight: bold; z-index: 100;
        }
        #btn-photo:hover { background: #d35400; }
    </style>
    <!-- Importazione Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">Caricamento...</div>

    <div id="ui-container">
        <div class="panel">
            <h3>Comandi</h3>
            <p><span class="key">â¬†â¬‡â¬…âž¡</span> Sposta</p>
            <p><span class="key">R</span> Ruota di 90Â°</p>
            <p><span class="key">Canc</span> Elimina</p>
        </div>
        <div class="panel">
            <div id="stats">Elementi: 0</div>
        </div>
    </div>

    <button id="btn-photo">ðŸ“· Foto</button>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- VARIABILI GLOBALI ---
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let cabinets = [];
        let selectedCabinet = null;
        let selectionBox;
        let floorMesh;
        
        // --- CONFIGURAZIONE ---
        const config = {
            step: 2,
            fastStep: 10,
            gridSize: 2000,
            showFloor: true
        };

        // --- LIBRERIA MATERIALI ---
        const matLib = {
            birch: new THREE.MeshStandardMaterial({ color: 0xF5DEB3, roughness: 0.5, name: 'birch' }), // Betulla
            white: new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.3, name: 'white' }), // Bianco
            walnut: new THREE.MeshStandardMaterial({ color: 0x5D4037, roughness: 0.6, name: 'walnut' }), // Noce
            
            // Materiali tecnici fissi
            top: new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.4 }),
            steel: new THREE.MeshStandardMaterial({ color: 0xbdc3c7, metalness: 0.8, roughness: 0.2 }),
            black: new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 }),
            kick: new THREE.MeshStandardMaterial({ color: 0x1a1a1a }),
            fire: new THREE.MeshBasicMaterial({ color: 0xe74c3c })
        };

        // --- PARAMETRI GUI ---
        const props = {
            // Stato Globale
            floorVisible: true,
            
            // Stato Modulo Selezionato
            type: 'base', 
            color: 'birch',
            width: 60, height: 85, depth: 60, elevation: 0, 
            rotation: 0, // Gradi
            x: 0, z: 0, 
            isOpen: false,

            // Azioni
            addBase: () => spawn('base'),
            addSink: () => spawn('sink'),
            addCook: () => spawn('cooktop'),
            addTall: () => spawn('tall'),
            addWall: () => spawn('wall'),
            delete: () => removeSelected()
        };

        const gui = new GUI({ title: 'Configuratore', width: 280 });
        gui.domElement.style.top = "10px";
        const ctrls = {};

        init();

        function init() {
            try {
                // 1. Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xdcdcdc);

                // 2. Camera Isometrica
                const aspect = window.innerWidth / window.innerHeight;
                const d = 600;
                camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 5000);
                camera.position.set(500, 500, 500); 
                camera.lookAt(0, 0, 0);

                // 3. Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(renderer.domElement);

                // 4. Luci
                const ambi = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambi);
                const sun = new THREE.DirectionalLight(0xffffff, 0.7);
                sun.position.set(300, 800, 500);
                sun.castShadow = true;
                sun.shadow.mapSize.set(2048, 2048);
                scene.add(sun);

                // 5. Pavimento e Griglia
                // Griglia
                const grid = new THREE.GridHelper(config.gridSize, 100, 0x999999, 0xbbbbbb);
                scene.add(grid);
                
                // Pavimento Neutro (Layer opzionale)
                const floorGeo = new THREE.PlaneGeometry(config.gridSize, config.gridSize);
                const floorMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 1 });
                floorMesh = new THREE.Mesh(floorGeo, floorMat);
                floorMesh.rotation.x = -Math.PI / 2;
                floorMesh.position.y = -0.5; // Appena sotto la griglia
                floorMesh.receiveShadow = true;
                scene.add(floorMesh);

                // 6. Helpers
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                
                // Box selezione
                selectionBox = new THREE.BoxHelper(new THREE.Mesh(), 0xff3300);
                selectionBox.visible = false;
                scene.add(selectionBox);

                // GUI Init
                setupGUI();

                // Events
                window.addEventListener('resize', onResize);
                window.addEventListener('keydown', onKeyDown);
                renderer.domElement.addEventListener('pointerdown', onClick);
                document.getElementById('btn-photo').addEventListener('click', takePhoto);

                document.getElementById('loader').style.display = 'none';

                // Esempio iniziale
                spawn('base', 0, 0, 'birch');
                spawn('sink', 60, 0, 'white');
                
                animate();
            } catch (e) {
                alert("Errore avvio: " + e.message);
            }
        }

        // --- SISTEMA GENERAZIONE ---

        function createCabinetGeometry(p) {
            const group = new THREE.Group();
            
            let toeH = (p.type === 'wall') ? 0 : 10;
            let topH = (p.type === 'base' || p.type === 'sink' || p.type === 'cooktop') ? 4 : 0;
            let bodyH = p.height - toeH - topH;
            
            // Materiale corpo scelto
            const bodyMat = matLib[p.color] || matLib.birch;

            // 1. CORPO PRINCIPALE
            const boxGeo = new THREE.BoxGeometry(p.width, bodyH, p.depth);
            const box = new THREE.Mesh(boxGeo, bodyMat);
            box.position.y = toeH + bodyH / 2;
            box.castShadow = true; box.receiveShadow = true;
            group.add(box);

            // 2. TOP E ACCESSORI
            if (topH > 0) {
                // Top standard base
                const topGeo = new THREE.BoxGeometry(p.width, topH, p.depth + 2);
                const top = new THREE.Mesh(topGeo, matLib.top);
                top.position.set(0, toeH + bodyH + topH/2, 1);
                top.castShadow = true;
                group.add(top);

                if (p.type === 'sink') {
                    // Vasca
                    const basin = new THREE.Mesh(new THREE.BoxGeometry(p.width-15, 12, p.depth-20), matLib.steel);
                    basin.position.set(0, toeH + bodyH + 5, 1);
                    group.add(basin);
                    // Rubinetto
                    const tap = new THREE.Mesh(new THREE.CylinderGeometry(1,1,12), matLib.steel);
                    tap.position.set(0, toeH + bodyH + 10, -10);
                    group.add(tap);
                } 
                else if (p.type === 'cooktop') {
                    // Piastra
                    const plate = new THREE.Mesh(new THREE.BoxGeometry(p.width-10, 1, p.depth-15), matLib.black);
                    plate.position.set(0, toeH + bodyH + topH + 0.5, 1);
                    group.add(plate);
                    // Fuochi (visuali)
                    const fire = new THREE.Mesh(new THREE.CylinderGeometry(2,2,0.5), matLib.fire);
                    fire.position.set(10, toeH + bodyH + topH + 1, 5);
                    group.add(fire);
                }
            }

            // 3. ANTE
            const doorGroup = new THREE.Group();
            const doorThick = 2;
            // Unica anta o doppia in base alla larghezza
            const isDouble = p.width >= 60;
            const doorW = isDouble ? (p.width/2)-0.2 : p.width-0.4;
            const doorH = bodyH - 0.4;

            if(isDouble) {
                const d1 = makeDoor(doorW, doorH, doorThick, bodyMat, 'left');
                d1.position.set(-p.width/4, 0, 0);
                const d2 = makeDoor(doorW, doorH, doorThick, bodyMat, 'right');
                d2.position.set(p.width/4, 0, 0);
                
                if(p.isOpen) {
                    d1.rotation.y = Math.PI/2.2; d1.position.z += 5;
                    d2.rotation.y = -Math.PI/2.2; d2.position.z += 5;
                }
                doorGroup.add(d1, d2);
            } else {
                const d1 = makeDoor(doorW, doorH, doorThick, bodyMat, 'left');
                if(p.isOpen) { d1.rotation.y = Math.PI/2.2; d1.position.z += 5; d1.position.x += doorW/2; }
                doorGroup.add(d1);
            }

            doorGroup.position.set(0, toeH + bodyH/2, p.depth/2 + doorThick/2);
            group.add(doorGroup);

            // 4. ZOCCOLO
            if(toeH > 0) {
                const kick = new THREE.Mesh(new THREE.BoxGeometry(p.width, toeH, p.depth-5), matLib.kick);
                kick.position.set(0, toeH/2, -2.5);
                group.add(kick);
            }

            return group;
        }

        function makeDoor(w, h, d, material, handleSide) {
            const grp = new THREE.Group();
            const panel = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), material);
            grp.add(panel);
            // Maniglia
            const han = new THREE.Mesh(new THREE.BoxGeometry(1.5, 10, 1.5), matLib.steel);
            const offset = (handleSide === 'left') ? w/2 - 5 : -w/2 + 5;
            han.position.set(offset, 5, d);
            grp.add(han);
            return grp;
        }

        // --- SPAWN & UPDATE ---

        function spawn(type, x=null, z=null, color='birch') {
            const defaults = {
                base: {h:85, d:60, y:0}, sink: {h:85, d:60, y:0}, cooktop: {h:85, d:60, y:0},
                tall: {h:210, d:60, y:0}, wall: {h:72, d:35, y:145}
            };
            const def = defaults[type];
            
            // Random pos se null
            if(x===null) x = (Math.random()*100)-50;
            if(z===null) z = (Math.random()*100)-50;

            const params = {
                id: Math.random().toString(36).substr(2, 9),
                type: type, color: color,
                width: 60, height: def.h, depth: def.d, elevation: def.y,
                rotation: 0,
                x: x, z: z,
                isOpen: false
            };
            renderCabinet(params);
        }

        function renderCabinet(params, isUpdate=false) {
            if(isUpdate) {
                const old = cabinets.find(c => c.params.id === params.id);
                if(old) {
                    scene.remove(old.mesh);
                    cabinets = cabinets.filter(c => c.params.id !== params.id);
                }
            }

            const mesh = createCabinetGeometry(params);
            
            // Posizionamento e Rotazione
            mesh.position.set(params.x, params.elevation, params.z);
            mesh.rotation.y = params.rotation * (Math.PI / 180); // Converte gradi in radianti

            // Metadata
            mesh.userData = { isCab: true, id: params.id };
            // Propaghiamo userdata ai figli per il raycasting
            mesh.traverse(obj => { obj.userData = { isCab: true, id: params.id } });

            scene.add(mesh);
            const obj = { mesh, params };
            cabinets.push(obj);

            document.getElementById('stats').innerText = "Elementi: " + cabinets.length;

            if(isUpdate || !selectedCabinet) select(obj);
            else if(selectedCabinet && selectedCabinet.params.id === params.id) select(obj);
        }

        // --- INTERAZIONE ---

        function select(obj) {
            selectedCabinet = obj;
            if(!obj) {
                selectionBox.visible = false;
                return;
            }
            
            selectionBox.setFromObject(obj.mesh);
            selectionBox.visible = true;

            // Sync UI
            ctrls.type.setValue(obj.params.type);
            ctrls.color.setValue(obj.params.color);
            ctrls.w.setValue(obj.params.width);
            ctrls.h.setValue(obj.params.height);
            ctrls.elv.setValue(obj.params.elevation);
            ctrls.rot.setValue(obj.params.rotation);
            ctrls.opn.setValue(obj.params.isOpen);
        }

        function removeSelected() {
            if(!selectedCabinet) return;
            scene.remove(selectedCabinet.mesh);
            cabinets = cabinets.filter(c => c !== selectedCabinet);
            select(null);
        }

        // --- INPUT ---

        function onKeyDown(e) {
            if (!selectedCabinet) {
                // Scorciatoie globali
                if(e.key === 'Delete') removeSelected();
                return;
            }
            
            const step = e.shiftKey ? config.fastStep : config.step;
            let dirty = false;
            let p = selectedCabinet.params;

            // Movimento
            if(e.key==='ArrowLeft') { p.x -= step; dirty=true; }
            if(e.key==='ArrowRight') { p.x += step; dirty=true; }
            if(e.key==='ArrowUp') { p.z -= step; dirty=true; }
            if(e.key==='ArrowDown') { p.z += step; dirty=true; }

            // Rotazione Rapida
            if(e.key === 'r' || e.key === 'R') {
                p.rotation = (p.rotation + 90) % 360;
                dirty = true;
                ctrls.rot.setValue(p.rotation);
            }
            
            if(e.key === 'Delete') { removeSelected(); dirty=false; }

            if(dirty) {
                selectedCabinet.mesh.position.set(p.x, p.elevation, p.z);
                selectedCabinet.mesh.rotation.y = p.rotation * (Math.PI/180);
                selectionBox.update();
            }
        }

        function onClick(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(scene.children, true);

            // Trova il primo oggetto che Ã¨ un mobile (ignorando box selezione e grid)
            const hit = hits.find(h => h.object.userData.isCab);
            
            if(hit) {
                const found = cabinets.find(c => c.params.id === hit.object.userData.id);
                select(found);
            } else if (hits.length === 0 || hits[0].object === floorMesh || hits[0].object.type === 'GridHelper') {
                select(null);
            }
        }

        // --- GUI ---

        function setupGUI() {
            // Folder Ambiente
            const fEnv = gui.addFolder('Ambiente');
            fEnv.add(props, 'floorVisible').name('Mostra Pavimento').onChange(v => floorMesh.visible = v);

            // Folder Aggiungi
            const fAdd = gui.addFolder('Aggiungi Moduli');
            fAdd.add(props, 'addBase').name('âž• Base');
            fAdd.add(props, 'addSink').name('âž• Lavandino');
            fAdd.add(props, 'addCook').name('âž• Piano Cottura');
            fAdd.add(props, 'addTall').name('âž• Armadio');
            fAdd.add(props, 'addWall').name('âž• Pensile');

            // Folder Modifica
            const fEdit = gui.addFolder('Modifica Selezionato');
            
            ctrls.type = fEdit.add(props, 'type', ['base','sink','cooktop','tall','wall']).name('Tipo').onChange(() => refreshSel());
            ctrls.color = fEdit.add(props, 'color', ['birch', 'white', 'walnut']).name('Colore').onChange(() => refreshSel());
            
            ctrls.w = fEdit.add(props, 'width', 20, 120, 5).name('Larghezza').onChange(v => updateParam('width', v));
            ctrls.h = fEdit.add(props, 'height', 20, 250, 5).name('Altezza').onChange(v => updateParam('height', v));
            
            ctrls.rot = fEdit.add(props, 'rotation', 0, 360, 5).name('Rotazione (Â°)').onChange(v => {
                if(selectedCabinet) {
                    selectedCabinet.params.rotation = v;
                    selectedCabinet.mesh.rotation.y = v * (Math.PI/180);
                    selectionBox.update();
                }
            });

            ctrls.elv = fEdit.add(props, 'elevation', 0, 250, 5).name('Elevazione Y').onChange(v => {
                if(selectedCabinet) {
                    selectedCabinet.params.elevation = v;
                    selectedCabinet.mesh.position.y = v;
                    selectionBox.update();
                }
            });

            ctrls.opn = fEdit.add(props, 'isOpen').name('Ante Aperte').onChange(v => updateParam('isOpen', v));
            fEdit.add(props, 'delete').name('ðŸ—‘ ELIMINA');
            
            fAdd.open();
            fEdit.open();
        }

        function updateParam(key, val) {
            if(!selectedCabinet) return;
            selectedCabinet.params[key] = val;
            renderCabinet(selectedCabinet.params, true);
        }

        function refreshSel() {
            if(selectedCabinet) {
                selectedCabinet.params.type = props.type;
                selectedCabinet.params.color = props.color;
                renderCabinet(selectedCabinet.params, true);
            }
        }

        function takePhoto() {
            render();
            const a = document.createElement('a');
            a.download = 'render_cucina.png';
            a.href = renderer.domElement.toDataURL('image/png');
            a.click();
        }

        function onResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 600;
            camera.left = -d * aspect; camera.right = d * aspect;
            camera.top = d; camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            render();
        }
        function render() { renderer.render(scene, camera); }

    </script>
</body>
</html>
