<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Kitchen Builder - GECO.srl Ultimate</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        /* --- DESIGN SYSTEM --- */
        :root { 
            --primary: #c58f68; 
            --dark: #3e3a36; 
            --bg-gradient: linear-gradient(135deg, #fdfbf7 0%, #f3efe7 100%);
            --glass: rgba(255, 255, 255, 0.9);
            --glass-border: 1px solid rgba(255, 255, 255, 0.6);
            --shadow: 0 10px 40px rgba(62, 58, 54, 0.15);
            --accent: #e07a5f;
        }

        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg-gradient); touch-action: none; user-select: none; }
        
        /* LOADER */
        #loader {
            position: fixed; inset: 0; z-index: 10000;
            background: #fdfbf7; display: flex; flex-direction: column;
            justify-content: center; align-items: center; transition: opacity 0.6s;
        }
        .loader-icon { font-size: 50px; animation: bounce 1s infinite; margin-bottom: 10px; }
        .loader-text { font-size: 16px; font-weight: 600; color: #555; letter-spacing: 2px; }
        .loader-sub { font-size: 12px; font-weight: 700; color: var(--primary); margin-top: 5px; opacity: 0.8; }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }

        /* UI LAYER */
        #ui-layer { position: absolute; inset: 0; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; overflow: hidden; }

        /* --- TOOLBAR INFERIORE --- */
        #toolbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 95%; max-width: 900px;
            display: flex; gap: 10px; pointer-events: auto;
            overflow-x: auto; padding: 10px;
            scrollbar-width: none; -ms-overflow-style: none; z-index: 100;
        }
        #toolbar::-webkit-scrollbar { display: none; }

        .panel {
            background: var(--glass); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border: var(--glass-border); border-radius: 18px; padding: 12px;
            box-shadow: var(--shadow);
            display: flex; flex-direction: column; gap: 8px;
            min-width: max-content;
        }
        
        .panel-title { 
            font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #8d7f75; 
            font-weight: 800; border-bottom: 1px solid rgba(0,0,0,0.06); padding-bottom: 5px; margin-bottom: 2px;
        }

        .btn-row { display: flex; gap: 6px; }

        .btn {
            background: rgba(255,255,255,0.7); border: 1px solid rgba(0,0,0,0.08);
            color: var(--dark); padding: 10px 16px; border-radius: 10px;
            font-size: 13px; font-weight: 600; cursor: pointer;
            display: flex; align-items: center; gap: 6px;
            transition: all 0.15s; white-space: nowrap;
            box-shadow: 0 2px 5px rgba(0,0,0,0.02);
        }
        .btn:active { transform: scale(0.95); background: var(--primary); color: white; }
        .btn-accent { color: var(--accent); background: rgba(224, 122, 95, 0.1); border-color: rgba(224, 122, 95, 0.2); }
        .btn.active { background: var(--primary); color: white; }

        /* --- D-PAD --- */
        #virtual-controls {
            position: absolute; right: 20px; bottom: 160px;
            display: flex; flex-direction: column; align-items: flex-end; gap: 15px;
            pointer-events: none; opacity: 0; transition: opacity 0.3s, transform 0.3s;
            transform: translateY(20px); z-index: 90;
        }
        #virtual-controls.visible { opacity: 1; pointer-events: auto; transform: translateY(0); }

        .d-pad { 
            background: rgba(255, 255, 255, 0.6); padding: 5px; border-radius: 50%; 
            display: grid; grid-template-columns: repeat(3, 50px); grid-template-rows: repeat(3, 50px);
            gap: 5px; backdrop-filter: blur(8px); box-shadow: var(--shadow);
        }
        .d-pad button:nth-child(1) { grid-column: 2; grid-row: 1; }
        .d-pad button:nth-child(2) { grid-column: 1; grid-row: 2; }
        .d-pad button:nth-child(3) { grid-column: 3; grid-row: 2; }
        .d-pad button:nth-child(4) { grid-column: 2; grid-row: 3; }

        .ctrl-btn {
            width: 100%; height: 100%; border-radius: 12px; border: none;
            background: #fff; color: var(--dark);
            font-size: 20px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .ctrl-btn:active { background: var(--primary); color: white; transform: scale(0.9); }
        .action-row { display: flex; gap: 10px; margin-right: 10px; }
        .btn-round { width: 50px; height: 50px; border-radius: 50%; }
        .btn-del { background: #fff0f0; color: #d63031; }

        /* --- TOOLTIP --- */
        #measure-tooltip {
            position: absolute; top: 0; left: 0;
            background: rgba(44, 44, 44, 0.95); color: white;
            padding: 6px 12px; border-radius: 20px; font-size: 12px; font-weight: 700;
            pointer-events: none; opacity: 0; transform: translate(-50%, -100%);
            margin-top: -15px; white-space: nowrap; z-index: 2000;
        }

        @media (min-width: 769px) {
            #toolbar { bottom: auto; top: 20px; left: 20px; transform: none; flex-direction: column; width: auto; max-height: 90vh; }
            .panel { width: 240px; }
            .btn-row { flex-wrap: wrap; }
            #virtual-controls { bottom: 40px; }
        }
    </style>
    
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

    <div id="loader">
        <div class="loader-icon">üõãÔ∏è</div>
        <div class="loader-text">KITCHEN BUILDER</div>
        <div class="loader-sub">GECO.srl</div>
    </div>

    <div id="ui-layer">
        
        <div id="toolbar">
            <!-- FILE -->
            <div class="panel">
                <div class="panel-title">Progetto</div>
                <div class="btn-row">
                    <button class="btn" onclick="app.saveProject()">üíæ Salva</button>
                    <button class="btn" onclick="app.loadProject()">üìÇ Apri</button>
                    <button class="btn btn-accent" onclick="app.generateRandom()">üé≤ Random</button>
                </div>
            </div>

            <!-- VIEW -->
            <div class="panel">
                <div class="panel-title">Strumenti</div>
                <div class="btn-row">
                    <button class="btn" onclick="app.takePhoto()">üì∑ Foto</button>
                    <button class="btn" id="btn-ingombro" onclick="app.toggleIngombro()">üìè Ingombro: OFF</button>
                </div>
            </div>

            <!-- MODULI CUCINA -->
            <div class="panel">
                <div class="panel-title">Cucina</div>
                <div class="btn-row" style="flex-wrap: nowrap; overflow-x: auto; padding-bottom: 5px;">
                    <button class="btn" onclick="app.spawn('base')">Base</button>
                    <button class="btn" onclick="app.spawn('sink')">Lavello</button>
                    <button class="btn" onclick="app.spawn('cooktop')">Fuochi</button>
                    <button class="btn" onclick="app.spawn('fridge')">Frigo</button>
                    <button class="btn" onclick="app.spawn('tall')">Colonna</button>
                    <button class="btn" onclick="app.spawn('wall')">Pensile</button>
                </div>
            </div>

            <!-- EXTRA & DECOR -->
            <div class="panel">
                <div class="panel-title">Extra & Decor</div>
                <div class="btn-row" style="flex-wrap: nowrap; overflow-x: auto; padding-bottom: 5px;">
                    <button class="btn" onclick="app.spawn('board_h')">Mensola</button>
                    <button class="btn" onclick="app.spawn('board_v')">Pannello</button>
                    <button class="btn" onclick="app.spawn('slatted')">Boiserie</button>
                    <button class="btn" onclick="app.spawn('led')">LED</button>
                    <button class="btn" onclick="app.spawn('door')">Porta</button>
                    <button class="btn" onclick="app.spawn('window')">Finestra</button>
                </div>
            </div>
        </div>

        <!-- D-PAD -->
        <div id="virtual-controls">
            <div class="d-pad">
                <button class="ctrl-btn" onpointerdown="app.startMove(0, -1)" onpointerup="app.stopMove()" onpointerleave="app.stopMove()">‚ñ≤</button>
                <button class="ctrl-btn" onpointerdown="app.startMove(-1, 0)" onpointerup="app.stopMove()" onpointerleave="app.stopMove()">‚óÑ</button>
                <button class="ctrl-btn" onpointerdown="app.startMove(1, 0)" onpointerup="app.stopMove()" onpointerleave="app.stopMove()">‚ñ∫</button>
                <button class="ctrl-btn" onpointerdown="app.startMove(0, 1)" onpointerup="app.stopMove()" onpointerleave="app.stopMove()">‚ñº</button>
            </div>
            <div class="action-row">
                <button class="ctrl-btn btn-round" onclick="app.rotate()">‚Üª</button>
                <button class="ctrl-btn btn-round" onclick="app.openDoor()">üö™</button>
                <button class="ctrl-btn btn-round btn-del" onclick="app.delete()">üóë</button>
            </div>
        </div>

        <div id="measure-tooltip"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- TEXTURES ---
        class TextureManager {
            constructor() { this.cache = {}; }
            getWood(hex) {
                const k='w_'+hex; if(this.cache[k])return this.cache[k];
                const c=document.createElement('canvas');c.width=256;c.height=256;
                const x=c.getContext('2d');x.fillStyle=hex;x.fillRect(0,0,256,256);
                x.globalAlpha=0.06;
                for(let i=0;i<30;i++){x.beginPath();x.moveTo(0,Math.random()*256);x.bezierCurveTo(80,Math.random()*256,170,Math.random()*256,256,Math.random()*256);x.strokeStyle='#6b5b4e';x.stroke();}
                const m=new THREE.MeshStandardMaterial({map:new THREE.CanvasTexture(c),roughness:0.6,metalness:0.05});
                this.cache[k]=m; return m;
            }
            getStone(hex) {
                const k='s_'+hex; if(this.cache[k])return this.cache[k];
                const c=document.createElement('canvas');c.width=256;c.height=256;
                const x=c.getContext('2d');x.fillStyle=hex;x.fillRect(0,0,256,256);
                x.globalAlpha=0.08;
                for(let i=0;i<1000;i++){x.fillStyle=Math.random()>.5?'#fff':'#555';x.fillRect(Math.random()*256,Math.random()*256,2,2);}
                const m=new THREE.MeshStandardMaterial({map:new THREE.CanvasTexture(c),roughness:0.9});
                this.cache[k]=m; return m;
            }
        }

        // --- GLOBALS ---
        let scene, camera, renderer, controls, raycaster, mouse, texManager;
        let cabinets = [], selection = [], selectionHelpers = [];
        let ingombroGroup = null, floorMesh, wallMesh;
        let isIngombroMode = false, moveInterval = null, mouseDownPos = new THREE.Vector2();
        
        const config = { step: 2, gridSize: 1800 };
        const props = {
            type: 'base', color: 'cream', width: 60, height: 85, depth: 60, elevation: 0,
            showFloor: true, showWall: true, wallColor: 'wall_cream',
            addBase:()=>linearSpawn('base'), addSink:()=>linearSpawn('sink'), addCook:()=>linearSpawn('cooktop'),
            addBoardH:()=>linearSpawn('board_h'), addBoardV:()=>linearSpawn('board_v'), addLed:()=>linearSpawn('led'),
            deleteSel:()=>deleteSelection()
        };

        const gui = new GUI({ title: 'Impostazioni', width: 280 }); gui.close();
        const ctrls = {};

        // --- APP ---
        window.app = {
            spawn: (t) => linearSpawn(t),
            saveProject: saveToJSON, loadProject: loadFromJSON, generateRandom: generateRandomKitchen,
            takePhoto: takePhoto, toggleIngombro: toggleIngombroMode,
            startMove: (x,z) => { moveSelection(x,z); moveInterval=setInterval(()=>moveSelection(x,z),100); },
            stopMove: () => clearInterval(moveInterval),
            rotate: () => rotateSelection(), delete: () => deleteSelection(),
            openDoor: () => { selection.forEach(c => { c.params.isOpen=!c.params.isOpen; rebuildCabinet(c); }); select(selection); }
        };

        init();

        function init() {
            texManager = new TextureManager();
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xfcfbf4);
            scene.fog = new THREE.Fog(0xfcfbf4, 300, 1500);

            const asp = window.innerWidth / window.innerHeight;
            // CAMERA VICINA (ZOOM)
            const d = window.innerWidth < 768 ? 240 : 170;
            camera = new THREE.OrthographicCamera(-d*asp, d*asp, d, -d, 1, 4000);
            camera.position.set(300, 300, 300);
            camera.lookAt(0, 50, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const amb = new THREE.AmbientLight(0xfff5e6, 0.75); scene.add(amb);
            const sun = new THREE.DirectionalLight(0xffffff, 0.65);
            sun.position.set(150, 400, 200); sun.castShadow = true;
            sun.shadow.mapSize.set(1024, 1024); sun.shadow.bias = -0.0005;
            scene.add(sun);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.08;
            controls.maxPolarAngle = Math.PI / 2; controls.target.set(0, 50, 0);

            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
            ingombroGroup = new THREE.Group(); scene.add(ingombroGroup);

            createEnv();
            setupGUI();

            window.addEventListener('resize', onResize);
            renderer.domElement.addEventListener('pointerdown', e => mouseDownPos.set(e.clientX, e.clientY));
            renderer.domElement.addEventListener('pointerup', onPointerUp);

            setTimeout(() => {
                generateRandomKitchen(); 
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').remove(), 600);
            }, 800);
            animate();
        }

        // --- MAT & ENV ---
        function getMaterial(n) {
            const p = { cream:'#fbf6e9', oak:'#dcbba0', walnut:'#a0886f', sand:'#d4cbb3', kick:'#dcdcdc' };
            if(p[n]) return texManager.getWood(p[n]);
            if(n==='glass') return new THREE.MeshPhysicalMaterial({ color:0xddeeff, transmission:0.7, transparent:true, opacity:0.3 });
            if(n==='led_light') return new THREE.MeshBasicMaterial({ color:0xfff4e0 });
            
            const t = {
                top: texManager.getStone('#edece6'),
                steel: new THREE.MeshStandardMaterial({ color:0xcccccc, metalness:0.6, roughness:0.4 }),
                black: new THREE.MeshStandardMaterial({ color:0x222222 }),
                wall_cream: new THREE.MeshStandardMaterial({ color:0xfcfcf7 }),
                wall_taupe: new THREE.MeshStandardMaterial({ color:0xd3cbb8 }),
                wall_sage: new THREE.MeshStandardMaterial({ color:0xc1cdb9 })
            };
            return t[n] || t.wall_cream;
        }

        function createEnv() {
            const w = new THREE.Mesh(new THREE.BoxGeometry(config.gridSize, 500, 10), getMaterial('wall_cream'));
            w.position.set(0, 250, -35); w.receiveShadow = true; scene.add(w); wallMesh = w;
            const f = new THREE.Mesh(new THREE.PlaneGeometry(config.gridSize, config.gridSize/2), texManager.getStone('#e8e4dc'));
            f.rotation.x = -Math.PI/2; f.position.set(0, -0.1, (config.gridSize/4) - 30);
            f.receiveShadow = true; scene.add(f); floorMesh = f;
            const g = new THREE.GridHelper(config.gridSize, 40, 0xd4a373, 0xeaddcf);
            g.position.set(0, 0.1, (config.gridSize/4) - 30); g.material.opacity=0.3; g.material.transparent=true; scene.add(g);
        }

        // --- LOGICA MODULI ---
        function linearSpawn(type) {
            const defs = { 
                base:[85,0,60], sink:[85,0,60], cooktop:[85,0,60], tall:[215,0,60], fridge:[215,0,60], wall:[72,145,35],
                board_h:[4,0,30], board_v:[85,0,4], slatted:[240,0,2], door:[210,0,10], window:[120,100,10], led:[1,0,1]
            };
            
            const [h, y, d] = defs[type] || [60,0,60];
            let w = (type==='door')?90:(type==='window'?120:(type==='slatted'?60:60));
            let tx=0, tz=0, trot=0, col=props.color;

            if (cabinets.length > 0) {
                const last = cabinets[cabinets.length-1];
                if(!['led','glass'].includes(last.params.color)) col = last.params.color;
                const rad = last.params.rotation * (Math.PI/180);
                const dist = (last.params.width/2) + (w/2);
                tx = last.params.x + Math.cos(rad) * dist;
                tz = last.params.z + Math.sin(rad) * dist;
                trot = last.params.rotation;
            }

            const p = { id:crypto.randomUUID(), type, color:col, width:w, height:h, depth:d, elevation:y, rotation:trot, x:tx, z:tz, isOpen:false };
            createCabinet(p, true);
        }

        function createCabinet(p, sel=false) {
            const mesh = buildMesh(p);
            mesh.userData = { isCab:true, id:p.id };
            scene.add(mesh);
            const obj = { mesh, params:p };
            cabinets.push(obj);
            if(sel) select([obj]);
            updateIngombro();
        }

        function rebuildCabinet(cab) {
            scene.remove(cab.mesh);
            cab.mesh = buildMesh(cab.params);
            cab.mesh.userData = { isCab:true, id:cab.params.id };
            scene.add(cab.mesh);
        }

        function buildMesh(p) {
            const grp = new THREE.Group();
            grp.position.set(p.x, p.elevation, p.z);
            grp.rotation.y = p.rotation * (Math.PI/180);

            // LOGICA MODULI EXTRA
            if(p.type === 'led') {
                const l = new THREE.Mesh(new THREE.BoxGeometry(p.width,1,1), getMaterial('led_light'));
                const pl = new THREE.PointLight(0xfff4e0, 0.5, 100); pl.position.set(0,-5,0); l.add(pl);
                grp.add(l); return grp;
            }
            if(p.type === 'window') {
                const f=5, m=getMaterial(p.color);
                const t=new THREE.Mesh(new THREE.BoxGeometry(p.width,f,p.depth),m); t.position.y=p.height/2-f/2;
                const b=new THREE.Mesh(new THREE.BoxGeometry(p.width,f,p.depth),m); b.position.y=-p.height/2+f/2;
                const l=new THREE.Mesh(new THREE.BoxGeometry(f,p.height,p.depth),m); l.position.x=-p.width/2+f/2;
                const r=new THREE.Mesh(new THREE.BoxGeometry(f,p.height,p.depth),m); r.position.x=p.width/2-f/2;
                const gl=new THREE.Mesh(new THREE.BoxGeometry(p.width-f*2,p.height-f*2,2),getMaterial('glass'));
                const wg=new THREE.Group(); wg.add(t,b,l,r,gl); wg.position.y=p.height/2; grp.add(wg); return grp;
            }
            if(p.type === 'door') {
                const f=5, m=getMaterial(p.color);
                const t=new THREE.Mesh(new THREE.BoxGeometry(p.width,f,p.depth),m); t.position.y=p.height-f/2;
                const l=new THREE.Mesh(new THREE.BoxGeometry(f,p.height,p.depth),m); l.position.set(-p.width/2+f/2,p.height/2,0);
                const r=new THREE.Mesh(new THREE.BoxGeometry(f,p.height,p.depth),m); r.position.set(p.width/2-f/2,p.height/2,0);
                const dp=new THREE.Mesh(new THREE.BoxGeometry(p.width-f*2,p.height-f,4),m); dp.position.y=(p.height-f)/2;
                const h=new THREE.Mesh(new THREE.BoxGeometry(2,12,4),getMaterial('steel')); h.position.set(p.width/2-15,100,4);
                const dg=new THREE.Group(); dg.add(dp,h); dg.position.set(-p.width/2+f,0,0);
                dp.position.x=(p.width-f*2)/2; h.position.x=(p.width-f*2)-10;
                if(p.isOpen) dg.rotation.y=Math.PI/2.5;
                grp.add(t,l,r,dg); return grp;
            }
            if(p.type === 'slatted') {
                const bk = new THREE.Mesh(new THREE.BoxGeometry(p.width,p.height,1), getMaterial(p.color));
                bk.position.y = p.height/2; grp.add(bk);
                const cnt = Math.floor(p.width/5);
                for(let i=0; i<cnt; i++){
                    const s=new THREE.Mesh(new THREE.BoxGeometry(3,p.height,p.depth), getMaterial(p.color));
                    s.position.set(-p.width/2+(i*5)+2.5, p.height/2, 1); grp.add(s);
                }
                return grp;
            }

            // MODULI STANDARD
            const toe = (p.type==='wall'||p.type==='fridge'||p.type.startsWith('board')) ? 0 : 10;
            const top = (['base','sink','cooktop'].includes(p.type)) ? 4 : 0;
            const body = p.height - toe - top;
            const mat = getMaterial(p.color);

            const box = new THREE.Mesh(new THREE.BoxGeometry(p.width, body, p.depth), mat);
            box.position.y = toe + body/2;
            box.castShadow = true; box.receiveShadow = true;
            if(mat.map) mat.map.repeat.set(p.width/100, body/100);
            grp.add(box);

            if(top>0) {
                const t = new THREE.Mesh(new THREE.BoxGeometry(p.width, top, p.depth+2), getMaterial('top'));
                t.position.set(0, toe+body+top/2, 1); t.castShadow = true; grp.add(t);
            }
            if(toe>0) {
                const k = new THREE.Mesh(new THREE.BoxGeometry(p.width-2, toe, p.depth-5), getMaterial('kick'));
                k.position.set(0, toe/2, -2.5); grp.add(k);
            }

            if(p.type==='fridge') {
                const f = new THREE.Mesh(new THREE.BoxGeometry(p.width-2, p.height-2, 2), mat);
                f.position.set(0, p.height/2, p.depth/2+1); grp.add(f);
            } else if (!p.type.startsWith('board')) {
                const dg = new THREE.Group(); dg.position.set(0, toe+body/2, p.depth/2+1);
                const is2 = p.width >= 70; const dw = is2 ? (p.width/2)-0.2 : p.width-0.4;
                if(is2) {
                    const d1=mkDoor(dw, body-0.4, mat, -1); d1.position.x = -p.width/4;
                    const d2=mkDoor(dw, body-0.4, mat, 1); d2.position.x = p.width/4;
                    if(p.isOpen) { d1.rotation.y=1.5; d2.rotation.y=-1.5; }
                    dg.add(d1, d2);
                } else {
                    const d1=mkDoor(dw, body-0.4, mat, 1);
                    if(p.isOpen) { d1.rotation.y=1.5; d1.position.x+=dw/2; }
                    dg.add(d1);
                }
                grp.add(dg);
            }

            if(p.type==='sink') {
                const s = new THREE.Mesh(new THREE.BoxGeometry(p.width-15, 15, p.depth-15), getMaterial('steel'));
                s.position.set(0, toe+body, 0); 
                const tap = new THREE.Mesh(new THREE.CylinderGeometry(1,1,15), getMaterial('steel'));
                tap.position.set(0, toe+body+8, -10); tap.rotation.x=0.3; grp.add(s, tap);
            }
            if(p.type==='cooktop') {
                const c = new THREE.Mesh(new THREE.BoxGeometry(p.width-15, 1, p.depth-15), getMaterial('black'));
                c.position.set(0, toe+body+top+0.5, 0); grp.add(c);
            }
            return grp;
        }

        function mkDoor(w, h, m, dir) {
            const g=new THREE.Group();
            const p=new THREE.Mesh(new THREE.BoxGeometry(w, h, 2), m); g.add(p);
            const hn=new THREE.Mesh(new THREE.BoxGeometry(1, 15, 1), getMaterial('steel'));
            hn.position.set(dir>0 ? -w/2+4 : w/2-4, 5, 2); g.add(hn); return g;
        }

        function moveSelection(dx, dz) {
            if(!selection.length) return;
            const s = config.step;
            selection.forEach(c => {
                c.params.x += dx*s; c.params.z += dz*s;
                c.mesh.position.set(c.params.x, c.params.elevation, c.params.z);
            });
            selectionHelpers.forEach(h=>h.update());
            updateTooltip(); updateIngombro();
        }

        function rotateSelection() {
            if(!selection.length) return;
            selection.forEach(c => {
                c.params.rotation = (c.params.rotation + 90) % 360;
                c.mesh.rotation.y = c.params.rotation * (Math.PI/180);
            });
            selectionHelpers.forEach(h=>h.update()); updateIngombro();
        }

        function deleteSelection() {
            selection.forEach(c => { scene.remove(c.mesh); cabinets=cabinets.filter(x=>x!==c); });
            select([]); updateIngombro();
        }

        function onPointerUp(e) {
            if(mouseDownPos.distanceTo(new THREE.Vector2(e.clientX,e.clientY))>10) return;
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left)/rect.width)*2 -1;
            mouse.y = -((e.clientY - rect.top)/rect.height)*2 +1;
            raycaster.setFromCamera(mouse, camera);
            
            const hits = raycaster.intersectObjects(scene.children, true);
            let target = null;
            for(let h of hits) {
                let p = h.object;
                while(p) { if(p.userData?.isCab){target=p; break;} p=p.parent; }
                if(target) break;
            }

            if(target) {
                const c = cabinets.find(x=>x.params.id===target.userData.id);
                if(e.shiftKey) {
                    const i = selection.indexOf(c);
                    if(i>=0) { const s=[...selection]; s.splice(i,1); select(s); }
                    else select([...selection, c]);
                } else if(!selection.includes(c)) select([c]);
            } else if(!hits.length || hits[0].object===floorMesh) {
                if(!e.shiftKey) select([]);
            }
        }

        function select(arr) {
            selection = arr;
            selectionHelpers.forEach(h=>scene.remove(h)); selectionHelpers=[];
            selection.forEach(c => {
                const b = new THREE.BoxHelper(c.mesh, 0xe07a5f);
                scene.add(b); selectionHelpers.push(b);
            });
            
            const ctrls = document.getElementById('virtual-controls');
            if(selection.length) {
                ctrls.classList.add('visible');
                const p = selection[0].params;
                Object.assign(props, { type:p.type, color:p.color, width:p.width, height:p.height, depth:p.depth, elevation:p.elevation });
                updateTooltip();
            } else {
                ctrls.classList.remove('visible');
                document.getElementById('measure-tooltip').style.opacity = 0;
            }
            updateIngombro();
        }

        function toggleIngombroMode() {
            isIngombroMode = !isIngombroMode;
            const btn = document.getElementById('btn-ingombro');
            btn.innerText = isIngombroMode ? "üìè Ingombro: ON" : "üìè Ingombro: OFF";
            btn.classList.toggle('active', isIngombroMode);
            updateIngombro();
        }

        function createLabel(txt) {
            const cv = document.createElement('canvas'); const cx = cv.getContext('2d');
            const fs = 36; cx.font = `bold ${fs}px Arial`;
            const m = cx.measureText(txt); const w = m.width+20; const h = fs+20;
            cv.width = w; cv.height = h;
            cx.fillStyle = 'rgba(255, 255, 255, 0.9)'; cx.beginPath(); cx.roundRect(0,0,w,h,10); cx.fill();
            cx.strokeStyle = '#c58f68'; cx.lineWidth=3; cx.stroke();
            cx.fillStyle = '#3e3a36'; cx.font = `bold ${fs}px Arial`;
            cx.textAlign = 'center'; cx.textBaseline = 'middle'; cx.fillText(txt, w/2, h/2);
            const tex = new THREE.CanvasTexture(cv); tex.minFilter=THREE.LinearFilter;
            const mat = new THREE.SpriteMaterial({ map:tex, depthTest:false, depthWrite:false });
            const sp = new THREE.Sprite(mat); sp.scale.set(0.0004*w, 0.0004*h, 1); sp.renderOrder = 9999;
            return sp;
        }

        function updateIngombro() {
            scene.remove(ingombroGroup); ingombroGroup = new THREE.Group(); scene.add(ingombroGroup);
            const lineMat = new THREE.LineBasicMaterial({ color: 0xc58f68, opacity:0.5, transparent:true, depthTest:false });

            cabinets.forEach(c => {
                // MOSTRA SE: Mode=ON OR modulo Selezionato
                if (isIngombroMode || selection.includes(c)) {
                    const b = new THREE.BoxHelper(c.mesh); b.material = lineMat; ingombroGroup.add(b);
                    const lg = new THREE.Group(); lg.position.copy(c.mesh.position); lg.rotation.y = c.mesh.rotation.y;
                    const p = c.params;
                    const lw = createLabel(`${p.width}`); lw.position.set(0, p.height/2+15, p.depth/2);
                    const lh = createLabel(`${p.height}`); lh.position.set(-p.width/2-15, p.height/2, p.depth/2);
                    const ld = createLabel(`${p.depth}`); ld.position.set(p.width/2+15, p.height/2, 0);
                    lg.add(lw, lh, ld); ingombroGroup.add(lg);
                }
            });
        }

        function generateRandomKitchen() {
            cabinets.forEach(c => scene.remove(c.mesh)); cabinets = []; select([]); scene.remove(ingombroGroup);
            let cx = -120; 
            createCabinet({ id:crypto.randomUUID(), type:'fridge', color:'cream', width:60, height:215, depth:60, elevation:0, rotation:0, x:cx, z:0, isOpen:false }); cx += 60;
            createCabinet({ id:crypto.randomUUID(), type:'base', color:'cream', width:60, height:85, depth:60, elevation:0, rotation:0, x:cx + 30, z:0, isOpen:false });
            createCabinet({ id:crypto.randomUUID(), type:'wall', color:'cream', width:60, height:72, depth:35, elevation:145, rotation:0, x:cx + 30, z:-12, isOpen:false }); cx += 60;
            createCabinet({ id:crypto.randomUUID(), type:'sink', color:'cream', width:90, height:85, depth:60, elevation:0, rotation:0, x:cx + 45, z:0, isOpen:false }); cx += 90;
            createCabinet({ id:crypto.randomUUID(), type:'cooktop', color:'cream', width:90, height:85, depth:60, elevation:0, rotation:0, x:cx + 45, z:0, isOpen:false });
            createCabinet({ id:crypto.randomUUID(), type:'wall', color:'cream', width:90, height:72, depth:35, elevation:145, rotation:0, x:cx + 45, z:-12, isOpen:false });
            updateIngombro();
        }

        function saveToJSON() { const d=cabinets.map(c=>c.params); const b=new Blob([JSON.stringify(d)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='GECO_Progetto.json'; a.click(); }
        function loadFromJSON() { const i=document.createElement('input'); i.type='file'; i.onchange=e=>{const r=new FileReader(); r.onload=v=>{cabinets.forEach(c=>scene.remove(c.mesh)); cabinets=[]; select([]); JSON.parse(v.target.result).forEach(p=>createCabinet(p)); updateIngombro();}; r.readAsText(e.target.files[0]);}; i.click(); }
        function takePhoto() { renderer.render(scene, camera); const a=document.createElement('a'); a.download='GECO_Render.png'; a.href=renderer.domElement.toDataURL('image/png'); a.click(); }

        function updateTooltip() {
            const t = document.getElementById('measure-tooltip');
            if(selection.length===1) {
                const p = selection[0].params;
                const v = new THREE.Vector3(p.x, p.elevation+p.height, p.z); v.project(camera);
                const x = (v.x*.5+.5)*window.innerWidth; const y = (-(v.y*.5-.5)*window.innerHeight);
                t.style.left=x+'px'; t.style.top=(y-30)+'px'; t.innerText=`L:${p.width} H:${p.height} P:${p.depth}`; t.style.opacity=1;
            } else t.style.opacity=0;
        }

        function setupGUI() {
            const apply = () => { selection.forEach(c=>Object.assign(c.params, props)); rebuildCabinet(selection[0]); }; 
            const f1 = gui.addFolder('Ambiente');
            f1.add(props, 'showFloor').onChange(v=>floorMesh.visible=v);
            f1.add(props, 'showWall').onChange(v=>wallMesh.visible=v);
            f1.add(props, 'wallColor', {Crema:'wall_cream', Tortora:'wall_taupe', Salvia:'wall_sage'}).onChange(v=>{wallMesh.material=getMaterial(v)});
            const f = gui.addFolder('Parametri Modulo');
            ctrls.c = f.add(props, 'color', {Crema:'cream', Rovere:'oak', Noce:'walnut', Sabbia:'sand'}).onChange(apply);
            ctrls.w = f.add(props, 'width', 1, 300).onChange(apply);
            ctrls.h = f.add(props, 'height', 1, 300).onChange(apply);
            ctrls.d = f.add(props, 'depth', 1, 200).onChange(apply);
            ctrls.e = f.add(props, 'elevation', 0, 300).onChange(apply);
            f.add(props, 'deleteSel');
        }

        function onResize() {
            const asp = window.innerWidth / window.innerHeight;
            const d = window.innerWidth < 768 ? 240 : 170;
            camera.left = -d*asp; camera.right = d*asp; camera.top = d; camera.bottom = -d;
            camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); updateTooltip(); }
    </script>
</body>
</html>
