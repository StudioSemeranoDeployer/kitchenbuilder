<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Kitchen Builder - GECO</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        :root { --primary: #c58f68; --glass: rgba(255,255,255,0.95); --shadow: 0 8px 32px rgba(0,0,0,0.1); }
        body { margin: 0; overflow: hidden; background: linear-gradient(135deg, #fdfbf7, #f3efe7); font-family: system-ui, sans-serif; user-select: none; touch-action: none; }
        
        #loader {
            position: fixed; inset: 0; background: #fdfbf7; z-index: 9999;
            display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.5s;
        }
        .loader-txt { font-weight: 800; font-size: 24px; color: #444; letter-spacing: 2px; }

        #ui-layer { position: absolute; inset: 0; pointer-events: none; }

        /* TOOLBAR */
        #toolbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 95%; max-width: 900px; display: flex; gap: 10px; pointer-events: auto;
            overflow-x: auto; padding: 10px; z-index: 100; scrollbar-width: none;
        }
        .panel {
            background: var(--glass); border-radius: 16px; padding: 10px;
            box-shadow: var(--shadow); border: 1px solid rgba(255,255,255,0.5);
            display: flex; flex-direction: column; gap: 5px; min-width: max-content;
        }
        .panel-head { font-size: 10px; text-transform: uppercase; color: #888; font-weight: 700; }
        .btn-row { display: flex; gap: 5px; }
        .btn {
            background: #fff; border: 1px solid #ddd; padding: 8px 12px; border-radius: 8px;
            font-size: 13px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 5px;
            transition: 0.2s; white-space: nowrap;
        }
        .btn:active { transform: scale(0.95); background: var(--primary); color: white; }
        .btn.active { background: var(--primary); color: white; border-color: var(--primary); }
        .btn-accent { background: rgba(224, 122, 95, 0.1); color: #d35400; }

        /* CONTROLS */
        #controls {
            position: absolute; right: 20px; bottom: 160px; pointer-events: auto;
            display: flex; flex-direction: column; align-items: flex-end; gap: 10px;
            opacity: 0; transform: translateY(20px); transition: 0.3s;
        }
        #controls.visible { opacity: 1; transform: translateY(0); }
        .d-pad {
            display: grid; grid-template-columns: repeat(3, 45px); gap: 5px;
            background: var(--glass); padding: 5px; border-radius: 50%; box-shadow: var(--shadow);
        }
        .pad-btn { width: 100%; height: 45px; border: none; background: #fff; border-radius: 8px; font-size: 18px; cursor: pointer; }
        .pad-btn:active { background: var(--primary); color: white; }
        .pad-btn:nth-child(1) { grid-column: 2; } 
        .pad-btn:nth-child(2) { grid-column: 1; }
        .pad-btn:nth-child(3) { grid-column: 3; }
        .pad-btn:nth-child(4) { grid-column: 2; }
        
        .actions { display: flex; gap: 10px; margin-right: 5px; }
        .act-btn { width: 45px; height: 45px; border-radius: 50%; border: none; background: #fff; font-size: 20px; cursor: pointer; box-shadow: var(--shadow); }
        .btn-del { color: red; background: #fff5f5; }

        #tooltip {
            position: absolute; background: rgba(30,30,30,0.9); color: white;
            padding: 5px 10px; border-radius: 4px; font-size: 11px; font-weight: bold;
            pointer-events: none; opacity: 0; transform: translate(-50%, -100%); margin-top: -15px;
        }
    </style>
    
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

<div id="loader">
    <div class="loader-txt">ü¶éGECO.srl</div>
    <div style="font-size:12px; color:#999; margin-top:5px;">CARICAMENTO SISTEMA...</div>
</div>

<div id="ui-layer">
    <div id="tooltip"></div>

    <div id="controls">
        <div class="d-pad">
            <button class="pad-btn" onpointerdown="app.move(0,-1)">‚ñ≤</button>
            <button class="pad-btn" onpointerdown="app.move(-1,0)">‚óÑ</button>
            <button class="pad-btn" onpointerdown="app.move(1,0)">‚ñ∫</button>
            <button class="pad-btn" onpointerdown="app.move(0,1)">‚ñº</button>
        </div>
        <div class="actions">
            <button class="act-btn" onclick="app.rotate()">‚Üª</button>
            <button class="act-btn" onclick="app.door()">üö™</button>
            <button class="act-btn btn-del" onclick="app.del()">üóë</button>
        </div>
    </div>

    <div id="toolbar">
        <div class="panel">
            <div class="panel-head">File</div>
            <div class="btn-row">
                <button class="btn" onclick="app.save()">üíæ</button>
                <button class="btn" onclick="app.load()">üìÇ</button>
                <button class="btn btn-accent" onclick="app.random()">üé≤ Random</button>
            </div>
        </div>
        <div class="panel">
            <div class="panel-head">Strumenti</div>
            <div class="btn-row">
                <button class="btn" onclick="app.photo()">üì∑</button>
                <button class="btn" id="btn-dim" onclick="app.toggleDims()">üìè Quote: OFF</button>
            </div>
        </div>
        <div class="panel">
            <div class="panel-head">Moduli</div>
            <div class="btn-row">
                <button class="btn" onclick="app.add('base')">Base</button>
                <button class="btn" onclick="app.add('sink')">Lavello</button>
                <button class="btn" onclick="app.add('cooktop')">Fuochi</button>
                <button class="btn" onclick="app.add('fridge')">Frigo</button>
                <button class="btn" onclick="app.add('tall')">Colonna</button>
                <button class="btn" onclick="app.add('wall')">Pensile</button>
            </div>
        </div>
        <div class="panel">
            <div class="panel-head">Extra</div>
            <div class="btn-row">
                <button class="btn" onclick="app.add('board_h')">Mensola</button>
                <button class="btn" onclick="app.add('board_v')">Pannello</button>
                <button class="btn" onclick="app.add('slatted')">Boiserie</button>
                <button class="btn" onclick="app.add('led')">LED</button>
                <button class="btn" onclick="app.add('door')">Porta</button>
                <button class="btn" onclick="app.add('window')">Finestra</button>
            </div>
        </div>
    </div>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

// --- CONFIG & STATE ---
let scene, camera, renderer, controls;
let cabinets = []; // Array dati
let meshes = [];   // Array oggetti 3D
let selection = [];
let helpers = [];
let dimGroup = null;
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let isDimMode = false;
let floor, wall;

const props = {
    color: 'white', 
    width: 60, height: 85, depth: 60, elevation: 0,
    wallColor: 'wall_cream', showEnv: true
};

const texCache = {};

// --- TEXTURE GENERATOR ---
function getTexture(type, colorHex) {
    const key = type + colorHex;
    if(texCache[key]) return texCache[key];

    const cv = document.createElement('canvas'); cv.width = 256; cv.height = 256;
    const ctx = cv.getContext('2d');
    
    // Sfondo solido
    ctx.fillStyle = colorHex; ctx.fillRect(0,0,256,256);
    
    // Effetto
    if(type === 'wood') {
        ctx.globalCompositeOperation = 'multiply';
        ctx.globalAlpha = 0.08;
        ctx.beginPath();
        for(let i=0; i<30; i++) {
            const y = Math.random()*256;
            ctx.moveTo(0, y); ctx.bezierCurveTo(80, y+20, 160, y-20, 256, y);
        }
        ctx.strokeStyle = '#555'; ctx.stroke();
    } else { // stone
        ctx.globalAlpha = 0.1;
        for(let i=0; i<500; i++) {
            ctx.fillStyle = Math.random()>.5?'#fff':'#000';
            ctx.fillRect(Math.random()*256, Math.random()*256, 2, 2);
        }
    }

    const tex = new THREE.CanvasTexture(cv);
    const mat = new THREE.MeshStandardMaterial({ 
        map: tex, 
        roughness: type==='wood'?0.6:0.9, 
        metalness: type==='wood'?0.05:0.1 
    });
    texCache[key] = mat;
    return mat;
}

function getMat(name) {
    const pal = { white:'#ffffff', cream:'#fdf6e3', oak:'#e6ccb2', walnut:'#a68a64', sand:'#ddb892', kick:'#dcdcdc' };
    if(pal[name]) return getTexture('wood', pal[name]);
    
    if(name === 'glass') return new THREE.MeshPhysicalMaterial({ color:0xaaccff, transmission:0.8, opacity:0.3, transparent:true });
    if(name === 'led') return new THREE.MeshBasicMaterial({ color:0xffffee });
    if(name === 'steel') return new THREE.MeshStandardMaterial({ color:0xcccccc, metalness:0.6, roughness:0.4 });
    if(name === 'black') return new THREE.MeshStandardMaterial({ color:0x222222 });
    if(name === 'wall_cream') return new THREE.MeshStandardMaterial({ color:0xfcfcf7 });
    if(name === 'wall_taupe') return new THREE.MeshStandardMaterial({ color:0xd3cbb8 });
    if(name === 'wall_sage') return new THREE.MeshStandardMaterial({ color:0xc1cdb9 });
    
    return getTexture('stone', '#e8e4dc'); // Default top
}

// --- INIT ---
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xfcfbf4);
    scene.fog = new THREE.Fog(0xfcfbf4, 300, 1200);

    const aspect = window.innerWidth / window.innerHeight;
    const d = window.innerWidth < 768 ? 220 : 160;
    camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 1, 4000);
    camera.position.set(300, 300, 300);
    camera.lookAt(0, 50, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const amb = new THREE.AmbientLight(0xfff0e0, 0.7); scene.add(amb);
    const sun = new THREE.DirectionalLight(0xffffff, 0.7);
    sun.position.set(150, 400, 200); sun.castShadow = true;
    sun.shadow.mapSize.set(1024, 1024); scene.add(sun);

    // Environment
    wall = new THREE.Mesh(new THREE.BoxGeometry(2000, 500, 10), getMat('wall_cream'));
    wall.position.set(0, 250, -35); wall.receiveShadow = true; scene.add(wall);

    floor = new THREE.Mesh(new THREE.PlaneGeometry(2000, 1000), getTexture('stone', '#eeeae5'));
    floor.rotation.x = -Math.PI/2; floor.position.set(0, -0.1, 200);
    floor.receiveShadow = true; scene.add(floor);

    const grid = new THREE.GridHelper(2000, 50, 0xccaacc, 0xeeddcc);
    grid.position.set(0, 0.1, 200); grid.material.opacity = 0.3; grid.material.transparent = true;
    scene.add(grid);

    dimGroup = new THREE.Group();
    scene.add(dimGroup);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.maxPolarAngle = Math.PI/2;

    setupGUI();
    window.addEventListener('resize', onResize);
    
    // EVENTI CLICK
    let downPos = new THREE.Vector2();
    renderer.domElement.addEventListener('pointerdown', e => downPos.set(e.clientX, e.clientY));
    renderer.domElement.addEventListener('pointerup', e => {
        if(downPos.distanceTo(new THREE.Vector2(e.clientX,e.clientY)) > 5) return;
        handleClick(e);
    });

    // AVVIO
    generateRandom();
    
    setTimeout(() => {
        document.getElementById('loader').style.opacity = 0;
        setTimeout(() => document.getElementById('loader').remove(), 500);
    }, 500);

    animate();
}

function onResize() {
    const aspect = window.innerWidth / window.innerHeight;
    const d = window.innerWidth < 768 ? 220 : 160;
    camera.left = -d*aspect; camera.right = d*aspect; camera.top = d; camera.bottom = -d;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// --- CORE FUNCTIONS ---
function createCabinet(p, selectIt) {
    // Aggiungi ai dati
    cabinets.push(p);
    
    // Crea Mesh
    const mesh = buildMesh(p);
    mesh.userData = { id: p.id }; // Link mesh -> data
    scene.add(mesh);
    meshes.push(mesh);

    if(selectIt) select([p.id]);
    else updateDims();
}

function buildMesh(p) {
    const grp = new THREE.Group();
    grp.position.set(p.x, p.elevation, p.z);
    grp.rotation.y = p.rotation * Math.PI/180;

    const mat = getMat(p.color);
    
    if(p.type==='led') {
        const m=new THREE.Mesh(new THREE.BoxGeometry(p.width,1,1), getMat('led'));
        m.add(new THREE.PointLight(0xffaa00, 0.5, 50)); grp.add(m);
    } 
    else if (p.type==='window'||p.type==='door') {
        // Cornice
        const fr = new THREE.Mesh(new THREE.BoxGeometry(p.width, p.height, p.depth), mat);
        // Vetro
        const gl = new THREE.Mesh(new THREE.BoxGeometry(p.width-10, p.height-10, p.depth+2), getMat('glass'));
        // Buco visivo (usiamo colori scuri per simulare profondit√† se non usiamo CSG)
        fr.add(gl);
        grp.add(fr);
        
        if(p.type==='door') {
            const h = new THREE.Mesh(new THREE.BoxGeometry(2,10,4), getMat('steel'));
            h.position.set(p.width/2-10, 0, p.depth/2+2);
            fr.add(h);
        }
    }
    else {
        const toe = (p.type==='wall'||p.type==='fridge'||p.type.startsWith('board')) ? 0 : 10;
        const top = (['base','sink','cooktop'].includes(p.type)) ? 4 : 0;
        const hBox = p.height - toe - top;

        const box = new THREE.Mesh(new THREE.BoxGeometry(p.width, hBox, p.depth), mat);
        box.position.y = toe + hBox/2;
        box.castShadow = true; box.receiveShadow = true;
        grp.add(box);

        if(toe>0) {
            const k = new THREE.Mesh(new THREE.BoxGeometry(p.width-2, toe, p.depth-5), getMat('kick'));
            k.position.set(0, toe/2, -2); grp.add(k);
        }
        if(top>0) {
            const t = new THREE.Mesh(new THREE.BoxGeometry(p.width, top, p.depth+2), getMat('stone'));
            t.position.set(0, toe+hBox+top/2, 1); t.castShadow = true; grp.add(t);
        }

        // ANTE
        if(!p.type.startsWith('board') && p.type !== 'fridge') {
            const isDouble = p.width>=70;
            const dw = isDouble ? (p.width/2)-0.2 : p.width-0.4;
            const dh = hBox-0.4;
            
            const makeDoor = (x, dir) => {
                const d = new THREE.Mesh(new THREE.BoxGeometry(dw, dh, 2), mat);
                const h = new THREE.Mesh(new THREE.BoxGeometry(1, 15, 1), getMat('steel'));
                h.position.set(dir*(dw/2-4), 0, 2); d.add(h);
                
                const piv = new THREE.Group();
                piv.position.set(x, toe+hBox/2, p.depth/2+1);
                d.position.x = -dir*(dw/2); // Offset
                piv.add(d);
                if(p.isOpen) piv.rotation.y = dir*1.5;
                return piv;
            };

            if(isDouble) {
                grp.add(makeDoor(-p.width/2, -1)); // SX
                grp.add(makeDoor(p.width/2, 1));   // DX (cardine a dx) - wait, cardine DX significa offset positivo
                // Fix double door logic:
                // SX: x=-width/2, cardine a SX. DX: x=width/2, cardine a DX.
                // Simplified:
                const d1 = new THREE.Mesh(new THREE.BoxGeometry(dw, dh, 2), mat); d1.position.set(-p.width/4, toe+hBox/2, p.depth/2+1);
                const d2 = new THREE.Mesh(new THREE.BoxGeometry(dw, dh, 2), mat); d2.position.set(p.width/4, toe+hBox/2, p.depth/2+1);
                if(p.isOpen) { d1.rotation.y = 1.2; d2.rotation.y = -1.2; } // Simple rotation
                grp.add(d1, d2);
            } else {
                // Singola, cardine SX
                const d = new THREE.Mesh(new THREE.BoxGeometry(dw, dh, 2), mat);
                const piv = new THREE.Group();
                piv.position.set(-p.width/2, toe+hBox/2, p.depth/2+1);
                d.position.x = p.width/2; 
                piv.add(d);
                if(p.isOpen) piv.rotation.y = 1.5;
                grp.add(piv);
            }
        }
        
        if(p.type==='sink') {
            const s = new THREE.Mesh(new THREE.BoxGeometry(p.width-20, 15, p.depth-20), getMat('steel'));
            s.position.set(0, p.height, 0); grp.add(s);
        }
        if(p.type==='cooktop') {
            const c = new THREE.Mesh(new THREE.BoxGeometry(p.width-20, 1, p.depth-20), getMat('black'));
            c.position.set(0, p.height, 0); grp.add(c);
        }
    }
    return grp;
}

// --- GESTIONE ---
function add(type) {
    let w=60, h=85, d=60, y=0;
    if(type==='sink'||type==='cooktop') w=90;
    if(type==='tall'||type==='fridge') h=215;
    if(type==='wall') { h=72; d=35; y=145; }
    if(type==='board_h') { h=4; d=30; }
    if(type==='board_v') { w=4; }
    if(type==='slatted') { h=240; d=2; }
    if(type==='door') { w=90; h=210; d=10; }
    if(type==='window') { w=120; h=120; d=10; y=100; }
    if(type==='led') { h=1; d=1; }

    let x=0, z=0, r=0, c=props.color;
    // Auto posizionamento
    if(selection.length > 0) {
        const ref = cabinets.find(cab => cab.id === selection[selection.length-1]);
        if(ref) {
            x = ref.x + ref.width/2 + w/2;
            z = ref.z;
            r = ref.rotation;
            if(!['led','glass'].includes(ref.color)) c = ref.color;
        }
    } else if (cabinets.length > 0) {
        const ref = cabinets[cabinets.length-1];
        x = ref.x + ref.width/2 + w/2;
        z = ref.z;
    }

    createCabinet({
        id: Math.random().toString(36),
        type, color: c, width:w, height:h, depth:d, elevation:y, rotation:r, x, z, isOpen:false
    }, true);
}

function handleClick(e) {
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((e.clientX - rect.left)/rect.width)*2 -1;
    mouse.y = -((e.clientY - rect.top)/rect.height)*2 +1;
    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(meshes, true);
    
    let hitId = null;
    for(let hit of hits) {
        let obj = hit.object;
        while(obj) { if(obj.userData.id) { hitId=obj.userData.id; break; } obj=obj.parent; }
        if(hitId) break;
    }

    if(hitId) {
        if(e.shiftKey) {
            if(selection.includes(hitId)) select(selection.filter(id=>id!==hitId));
            else select([...selection, hitId]);
        } else {
            select([hitId]);
        }
    } else if (hits.length === 0) {
        if(!e.shiftKey) select([]);
    }
}

function select(ids) {
    selection = ids;
    helpers.forEach(h=>scene.remove(h)); helpers=[];
    
    selection.forEach(id => {
        const m = meshes.find(m => m.userData.id === id);
        if(m) {
            const box = new THREE.BoxHelper(m, 0xe07a5f);
            scene.add(box); helpers.push(box);
        }
    });

    const panel = document.getElementById('controls');
    if(selection.length) {
        panel.classList.add('visible');
        // Sync GUI
        const last = cabinets.find(c=>c.id===selection[selection.length-1]);
        if(last) {
            props.color = last.color;
            props.width = last.width;
            props.height = last.height;
            props.depth = last.depth;
            props.elevation = last.elevation;
            // update gui display manually not strictly needed but good
        }
    } else {
        panel.classList.remove('visible');
    }
    updateDims();
    updateTooltip();
}

function updateProps() {
    selection.forEach(id => {
        const idx = cabinets.findIndex(c=>c.id===id);
        if(idx>=0) {
            Object.assign(cabinets[idx], props); // merge props
            // Rebuild
            const oldMesh = meshes.find(m=>m.userData.id===id);
            scene.remove(oldMesh);
            meshes = meshes.filter(m=>m!==oldMesh);
            
            const newMesh = buildMesh(cabinets[idx]);
            newMesh.userData = { id: id };
            scene.add(newMesh);
            meshes.push(newMesh);
        }
    });
    select(selection); // Refresh helpers
}

// --- DIMENSIONS ---
function createLabel(txt) {
    const cv = document.createElement('canvas'); cv.width=128; cv.height=64;
    const ctx = cv.getContext('2d');
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.beginPath(); ctx.roundRect(0,0,128,64,12); ctx.fill();
    ctx.strokeStyle = '#c58f68'; ctx.lineWidth=4; ctx.stroke();
    ctx.fillStyle='#000'; ctx.font='bold 28px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(txt, 64, 32);
    const s = new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(cv), depthTest:false}));
    s.scale.set(30,15,1); s.renderOrder=999;
    return s;
}

function updateDims() {
    dimGroup.clear();
    if(selection.length === 0 && !isDimMode) return;

    cabinets.forEach(c => {
        // Mostra se Mode=ON oppure se fa parte della Selezione
        if(isDimMode || selection.includes(c.id)) {
            const m = meshes.find(x=>x.userData.id===c.id);
            if(!m) return;
            
            // Box
            const b = new THREE.BoxHelper(m, 0xc58f68);
            b.material.opacity=0.4; b.material.transparent=true; b.material.depthTest=false;
            dimGroup.add(b);

            // Labels
            const w = createLabel(c.width); w.position.copy(m.position); w.position.y += c.height/2+15;
            const h = createLabel(c.height); h.position.copy(m.position); h.position.x -= c.width/2+15;
            const d = createLabel(c.depth); d.position.copy(m.position); d.position.x += c.width/2+15;
            dimGroup.add(w,h,d);
        }
    });
}

function updateTooltip() {
    const tt = document.getElementById('tooltip');
    if(selection.length === 1) {
        const c = cabinets.find(x=>x.id===selection[0]);
        const v = new THREE.Vector3(c.x, c.elevation+c.height, c.z).project(camera);
        const x = (v.x*.5+.5)*window.innerWidth;
        const y = (-(v.y*.5-.5)*window.innerHeight);
        tt.style.left = x+'px'; tt.style.top = (y-30)+'px';
        tt.innerHTML = `${c.width} x ${c.height} x ${c.depth}`;
        tt.style.opacity = 1;
    } else tt.style.opacity=0;
}

// --- UTILS ---
function generateRandom() {
    cabinets = []; meshes.forEach(m=>scene.remove(m)); meshes=[]; select([]);
    let cx = -120;
    // Helper to add without selection
    const addR = (t,w,h,d,e,x,z) => {
        const p = {id:Math.random().toString(36), type:t, color:'white', width:w, height:h, depth:d, elevation:e, x, z, rotation:0, isOpen:false};
        createCabinet(p, false);
    };
    addR('fridge', 60, 215, 60, 0, cx, 0); cx+=60;
    addR('base', 60, 85, 60, 0, cx+30, 0); 
    addR('wall', 60, 72, 35, 145, cx+30, -12); cx+=60;
    addR('sink', 90, 85, 60, 0, cx+45, 0); cx+=90;
    addR('cooktop', 90, 85, 60, 0, cx+45, 0); 
    addR('wall', 90, 72, 35, 145, cx+45, -12);
    
    updateDims();
}

function setupGUI() {
    const gui = new GUI({ width: 260 }); gui.close();
    const f = gui.addFolder('Modifica');
    f.add(props, 'color', ['white','cream','oak','walnut','sand']).onChange(updateProps);
    f.add(props, 'width', 10, 300).onChange(updateProps);
    f.add(props, 'height', 10, 300).onChange(updateProps);
    f.add(props, 'depth', 10, 200).onChange(updateProps);
    f.add(props, 'elevation', 0, 300).onChange(updateProps);
    f.add(props, 'wallColor', ['wall_cream','wall_taupe','wall_sage']).onChange(v => wall.material=getMat(v));
}

// --- EXPORT API ---
window.app = {
    add: spawn,
    save: () => {
        const b = new Blob([JSON.stringify(cabinets)], {type:'json'});
        const a = document.createElement('a'); a.href=URL.createObjectURL(b); a.download='geco_project.json'; a.click();
    },
    load: () => {
        const i = document.createElement('input'); i.type='file';
        i.onchange=e=>{
            const r=new FileReader(); r.onload=v=>{
                cabinets=[]; meshes.forEach(m=>scene.remove(m)); meshes=[]; select([]);
                JSON.parse(v.target.result).forEach(p=>createCabinet(p,false));
            }; r.readAsText(e.target.files[0]);
        }; i.click();
    },
    random: generateRandom,
    photo: () => { renderer.render(scene, camera); const a=document.createElement('a'); a.href=renderer.domElement.toDataURL(); a.download='render.png'; a.click(); },
    toggleDims: () => { 
        isDimMode=!isDimMode; 
        document.getElementById('btn-dim').innerText = isDimMode ? "üìè Quote: ON" : "üìè Quote: OFF";
        document.getElementById('btn-dim').classList.toggle('active', isDimMode);
        updateDims(); 
    },
    move: (x,z) => {
        selection.forEach(id => {
            const c = cabinets.find(x=>x.id===id);
            c.x += x*2; c.z += z*2;
            const m = meshes.find(x=>x.userData.id===id);
            m.position.set(c.x, c.elevation, c.z);
        });
        select(selection); // Refresh helpers
    },
    rotate: () => {
        selection.forEach(id => {
            const c = cabinets.find(x=>x.id===id);
            c.rotation = (c.rotation+90)%360;
            const m = meshes.find(x=>x.userData.id===id);
            m.rotation.y = c.rotation * Math.PI/180;
        });
        select(selection);
    },
    door: () => {
        selection.forEach(id => {
            const c = cabinets.find(x=>x.id===id);
            c.isOpen = !c.isOpen;
        });
        updateProps(); // Rebuild
    },
    del: deleteSel
};

function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
}
}
init();
</script>
</body>
</html>
