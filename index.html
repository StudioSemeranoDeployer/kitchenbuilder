<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Kitchen Builder - Stable Fix</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #2c3e50; }
        
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #2c3e50; color: white; display: flex; 
            justify-content: center; align-items: center; font-size: 20px; z-index: 9999;
        }

        #ui-container {
            position: absolute; top: 10px; left: 10px; pointer-events: none;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px; border-radius: 8px; margin-bottom: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            max-width: 260px; pointer-events: auto;
        }

        h3 { margin: 0 0 5px 0; color: #333; }
        p { margin: 0; font-size: 13px; color: #666; }
        .key { display: inline-block; background: #eee; border: 1px solid #ccc; border-radius: 4px; padding: 2px 6px; font-weight: bold; font-size: 11px; }

        #btn-photo {
            position: absolute; top: 20px; right: 20px;
            background: #e67e22; color: white; border: none;
            padding: 10px 20px; border-radius: 6px; cursor: pointer;
            font-weight: bold; z-index: 100;
        }
        #btn-photo:hover { background: #d35400; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">Caricamento in corso...</div>

    <div id="ui-container">
        <div class="panel">
            <h3>Comandi</h3>
            <p><span class="key">Frecce</span> Sposta</p>
            <p><span class="key">R</span> Ruota</p>
            <p><span class="key">Canc</span> Elimina</p>
        </div>
        <div class="panel">
            <div id="stats">Elementi: 0</div>
        </div>
    </div>

    <button id="btn-photo">ðŸ“· Foto</button>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- VARIABILI ---
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let cabinets = [];
        let selectedCabinet = null;
        let selectionBox;
        let floorMesh;
        
        // Materiali condivisi
        const matLib = {
            birch: new THREE.MeshStandardMaterial({ color: 0xF5DEB3, roughness: 0.5, name: 'birch' }),
            white: new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.3, name: 'white' }),
            walnut: new THREE.MeshStandardMaterial({ color: 0x5D4037, roughness: 0.6, name: 'walnut' }),
            top: new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.4 }),
            steel: new THREE.MeshStandardMaterial({ color: 0xbdc3c7, metalness: 0.8 }),
            black: new THREE.MeshStandardMaterial({ color: 0x111111 }),
            kick: new THREE.MeshStandardMaterial({ color: 0x1a1a1a }),
            fire: new THREE.MeshBasicMaterial({ color: 0xe74c3c })
        };

        const config = { step: 2, fastStep: 10, gridSize: 2000 };

        // Stato GUI
        const props = {
            floorVisible: true,
            type: 'base', color: 'birch',
            width: 60, height: 85, depth: 60, elevation: 0, 
            rotation: 0, x: 0, z: 0, isOpen: false,
            // Azioni
            addBase: () => spawn('base'),
            addSink: () => spawn('sink'),
            addCook: () => spawn('cooktop'),
            addTall: () => spawn('tall'),
            addWall: () => spawn('wall'),
            del: () => removeSelected()
        };

        const gui = new GUI({ title: 'Menu', width: 280 });
        gui.domElement.style.top = "10px";
        const ctrls = {};

        init();

        function init() {
            try {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xdcdcdc);

                const aspect = window.innerWidth / window.innerHeight;
                const d = 600;
                camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 1, 5000);
                camera.position.set(500, 500, 500); 
                camera.lookAt(0,0,0);

                renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(renderer.domElement);

                // Luci
                scene.add(new THREE.AmbientLight(0xffffff, 0.6));
                const sun = new THREE.DirectionalLight(0xffffff, 0.7);
                sun.position.set(300, 800, 500);
                sun.castShadow = true;
                sun.shadow.mapSize.set(2048, 2048);
                scene.add(sun);

                // Pavimento
                scene.add(new THREE.GridHelper(config.gridSize, 100, 0x999999, 0xbbbbbb));
                floorMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(config.gridSize, config.gridSize),
                    new THREE.MeshStandardMaterial({ color: 0xeeeeee })
                );
                floorMesh.rotation.x = -Math.PI / 2;
                floorMesh.position.y = -0.5;
                floorMesh.receiveShadow = true;
                scene.add(floorMesh);

                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                
                selectionBox = new THREE.BoxHelper(new THREE.Mesh(), 0xff3300);
                selectionBox.visible = false;
                scene.add(selectionBox);

                setupGUI();

                window.addEventListener('resize', onResize);
                window.addEventListener('keydown', onKeyDown);
                renderer.domElement.addEventListener('pointerdown', onClick);
                document.getElementById('btn-photo').addEventListener('click', takePhoto);

                document.getElementById('loader').style.display = 'none';

                // Moduli iniziali
                spawn('base', 0, 0, 'birch');
                spawn('wall', 0, 0, 'white');

                animate();
            } catch (e) {
                alert("Errore Critico: " + e.message);
            }
        }

        // --- GENERATORE GEOMETRIA ---

        function createCabinetGroup(p) {
            const group = new THREE.Group();
            
            // Imposta altezza corpo
            let toeH = (p.type === 'wall') ? 0 : 10;
            let topH = (['base','sink','cooktop'].includes(p.type)) ? 4 : 0;
            let bodyH = p.height - toeH - topH;
            
            const mat = matLib[p.color] || matLib.birch;

            // 1. Corpo
            const box = new THREE.Mesh(new THREE.BoxGeometry(p.width, bodyH, p.depth), mat);
            box.position.y = toeH + bodyH / 2;
            box.castShadow = true; box.receiveShadow = true;
            group.add(box);

            // 2. Top
            if (topH > 0) {
                const top = new THREE.Mesh(new THREE.BoxGeometry(p.width, topH, p.depth+2), matLib.top);
                top.position.set(0, toeH + bodyH + topH/2, 1);
                top.castShadow = true;
                group.add(top);

                if (p.type === 'sink') {
                    const basin = new THREE.Mesh(new THREE.BoxGeometry(p.width-15, 12, p.depth-15), matLib.steel);
                    basin.position.set(0, toeH + bodyH + 2, 1);
                    group.add(basin);
                    const tap = new THREE.Mesh(new THREE.CylinderGeometry(1,1,15), matLib.steel);
                    tap.position.set(0, toeH + bodyH + 10, -10);
                    group.add(tap);
                }
                if (p.type === 'cooktop') {
                    const plate = new THREE.Mesh(new THREE.BoxGeometry(p.width-10, 1, p.depth-10), matLib.black);
                    plate.position.set(0, toeH + bodyH + topH + 0.5, 1);
                    group.add(plate);
                    group.add(new THREE.Mesh(new THREE.CylinderGeometry(2,2,0.5), matLib.fire).translateX(10).translateY(toeH+bodyH+topH+1));
                }
            }

            // 3. Ante
            const doorGrp = new THREE.Group();
            const isDouble = p.width >= 60;
            const dW = isDouble ? (p.width/2)-0.2 : p.width-0.4;
            const dH = bodyH - 0.4;

            if(isDouble) {
                const d1 = makeDoor(dW, dH, mat, -1); 
                d1.position.set(-p.width/4, 0, 0);
                const d2 = makeDoor(dW, dH, mat, 1);
                d2.position.set(p.width/4, 0, 0);
                if(p.isOpen) {
                    d1.rotation.y = Math.PI/2.5; d1.position.z+=5;
                    d2.rotation.y = -Math.PI/2.5; d2.position.z+=5;
                }
                doorGrp.add(d1, d2);
            } else {
                const d1 = makeDoor(dW, dH, mat, 1);
                if(p.isOpen) { d1.rotation.y = Math.PI/2.5; d1.position.z+=5; d1.position.x += dW/2; }
                doorGrp.add(d1);
            }
            doorGrp.position.set(0, toeH + bodyH/2, p.depth/2 + 1);
            group.add(doorGrp);

            // 4. Zoccolo
            if(toeH>0) {
                const kick = new THREE.Mesh(new THREE.BoxGeometry(p.width, toeH, p.depth-5), matLib.kick);
                kick.position.set(0, toeH/2, -2.5);
                group.add(kick);
            }

            return group;
        }

        function makeDoor(w, h, mat, handleDir) {
            const g = new THREE.Group();
            g.add(new THREE.Mesh(new THREE.BoxGeometry(w, h, 2), mat));
            const han = new THREE.Mesh(new THREE.BoxGeometry(1.5, 10, 1.5), matLib.steel);
            han.position.set((handleDir>0 ? -w/2+5 : w/2-5), 5, 2);
            g.add(han);
            return g;
        }

        // --- GESTIONE OGGETTI ---

        function spawn(type, x=null, z=null, col='birch') {
            const defs = { base:[85,0], sink:[85,0], cooktop:[85,0], tall:[210,0], wall:[72,145] };
            
            if(x===null) x = (Math.random()*100)-50;
            if(z===null) z = (Math.random()*100)-50;

            const params = {
                id: 'id_'+Math.random().toString(36).substr(2,9),
                type: type, color: col,
                width: 60, height: defs[type][0], depth: (type==='wall'?35:60), elevation: defs[type][1],
                rotation: 0, x: x, z: z, isOpen: false
            };

            updateCabinetMesh(params, true);
        }

        function updateCabinetMesh(params, isNew = false) {
            // Rimuovi vecchio se esiste
            if (!isNew) {
                const old = cabinets.find(c => c.params.id === params.id);
                if (old) {
                    scene.remove(old.mesh);
                    cabinets = cabinets.filter(c => c.params.id !== params.id);
                }
            }

            // Crea nuova mesh
            const mesh = createCabinetGroup(params);
            
            // Posiziona
            mesh.position.set(params.x, params.elevation, params.z);
            mesh.rotation.y = params.rotation * (Math.PI / 180);
            
            // Metadata fondamentali per il raycasting
            mesh.userData = { isCab: true, id: params.id };
            
            scene.add(mesh);
            
            const newObj = { mesh, params };
            cabinets.push(newObj);
            document.getElementById('stats').innerText = "Elementi: " + cabinets.length;

            // Se stiamo aggiornando un oggetto giÃ  selezionato, aggiorniamo il riferimento
            if (selectedCabinet && selectedCabinet.params.id === params.id) {
                selectedCabinet = newObj;
                selectionBox.setFromObject(mesh);
            } 
            // Se Ã¨ nuovo, lo selezioniamo
            else if (isNew) {
                select(newObj);
            }
        }

        // --- SELEZIONE SICURA (FIX LOOP) ---

        function select(obj) {
            selectedCabinet = obj;
            
            if(!obj) {
                selectionBox.visible = false;
                return;
            }

            selectionBox.setFromObject(obj.mesh);
            selectionBox.visible = true;

            // Aggiorniamo la GUI ma SENZA scatenare eventi onChange
            // lil-gui 'listen()' rileva le modifiche a 'props', ma qui le forziamo manualmente
            // per essere sicuri che i valori visualizzati siano corretti.
            const p = obj.params;
            
            // Copiamo i valori nell'oggetto props collegato alla GUI
            Object.assign(props, {
                type: p.type, color: p.color,
                width: p.width, height: p.height, depth: p.depth,
                elevation: p.elevation, rotation: p.rotation,
                x: p.x, z: p.z, isOpen: p.isOpen
            });

            // Aggiorniamo solo il display visuale dei controller
            for (let k in ctrls) ctrls[k].updateDisplay();
        }

        function removeSelected() {
            if(!selectedCabinet) return;
            scene.remove(selectedCabinet.mesh);
            cabinets = cabinets.filter(c => c !== selectedCabinet);
            select(null);
            document.getElementById('stats').innerText = "Elementi: " + cabinets.length;
        }

        // --- INPUT ---

        function onKeyDown(e) {
            if (!selectedCabinet) {
                if(e.key==='Delete') removeSelected();
                return;
            }
            
            const step = e.shiftKey ? config.fastStep : config.step;
            let changed = false;
            let p = selectedCabinet.params;

            if(e.key==='ArrowLeft') { p.x -= step; changed=true; }
            if(e.key==='ArrowRight') { p.x += step; changed=true; }
            if(e.key==='ArrowUp') { p.z -= step; changed=true; }
            if(e.key==='ArrowDown') { p.z += step; changed=true; }
            
            if(e.key==='r' || e.key==='R') {
                p.rotation = (p.rotation + 90) % 360;
                changed=true;
            }
            
            if(e.key==='Delete') { removeSelected(); changed=false; }

            if(changed) {
                // Aggiorniamo direttaemnte la mesh per fluiditÃ 
                selectedCabinet.mesh.position.set(p.x, p.elevation, p.z);
                selectedCabinet.mesh.rotation.y = p.rotation * (Math.PI/180);
                selectionBox.update();
                
                // Aggiorniamo i valori GUI props e display
                props.x = p.x; props.z = p.z; props.rotation = p.rotation;
                ctrls.x.updateDisplay(); ctrls.z.updateDisplay(); ctrls.rot.updateDisplay();
            }
        }

        function onClick(e) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(scene.children, true);

            // Trova il parent con isCab
            let found = null;
            for(let hit of hits) {
                let obj = hit.object;
                // Risaliamo la gerarchia fino a trovare il gruppo con userData.isCab
                while(obj) {
                    if(obj.userData && obj.userData.isCab) {
                        found = obj;
                        break;
                    }
                    obj = obj.parent;
                }
                if(found) break;
            }

            if(found) {
                const cab = cabinets.find(c => c.params.id === found.userData.id);
                select(cab);
            } else if (hits.length === 0 || hits[0].object === floorMesh || hits[0].object.type === 'GridHelper') {
                select(null);
            }
        }

        // --- GUI ---

        function setupGUI() {
            const fEnv = gui.addFolder('Ambiente');
            fEnv.add(props, 'floorVisible').name('Pavimento').onChange(v => floorMesh.visible = v);

            const fAdd = gui.addFolder('Aggiungi');
            fAdd.add(props, 'addBase').name('+ Base');
            fAdd.add(props, 'addSink').name('+ Lavandino');
            fAdd.add(props, 'addCook').name('+ Cottura');
            fAdd.add(props, 'addTall').name('+ Armadio');
            fAdd.add(props, 'addWall').name('+ Pensile');

            const fEdit = gui.addFolder('Modifica');
            
            // Usiamo wrapper function per evitare loop
            const apply = () => {
                if(selectedCabinet) {
                    // Aggiorna params da props
                    Object.assign(selectedCabinet.params, {
                        type: props.type, color: props.color,
                        width: props.width, height: props.height, depth: props.depth,
                        elevation: props.elevation, rotation: props.rotation,
                        isOpen: props.isOpen
                    });
                    updateCabinetMesh(selectedCabinet.params);
                }
            };

            ctrls.type = fEdit.add(props, 'type', ['base','sink','cooktop','tall','wall']).onChange(apply);
            ctrls.color = fEdit.add(props, 'color', ['birch','white','walnut']).onChange(apply);
            ctrls.w = fEdit.add(props, 'width', 20, 120, 5).onChange(apply);
            ctrls.h = fEdit.add(props, 'height', 20, 250, 5).onChange(apply);
            ctrls.rot = fEdit.add(props, 'rotation', 0, 360, 5).onChange(apply);
            ctrls.elv = fEdit.add(props, 'elevation', 0, 250, 5).onChange(apply);
            
            // Coordinate solo visualizzazione (aggiornate via tastiera o qui)
            ctrls.x = fEdit.add(props, 'x').listen().onChange(v => {
                if(selectedCabinet) { selectedCabinet.params.x = v; apply(); }
            });
            ctrls.z = fEdit.add(props, 'z').listen().onChange(v => {
                if(selectedCabinet) { selectedCabinet.params.z = v; apply(); }
            });
            
            ctrls.opn = fEdit.add(props, 'isOpen').name('Ante Aperte').onChange(apply);
            fEdit.add(props, 'del').name('ðŸ—‘ Elimina');

            fAdd.open();
            fEdit.open();
        }

        function takePhoto() {
            render();
            const a = document.createElement('a');
            a.download = 'cucina.png';
            a.href = renderer.domElement.toDataURL('image/png');
            a.click();
        }

        function onResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 600;
            camera.left = -d * aspect; camera.right = d * aspect;
            camera.top = d; camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            render();
        }
        function render() { renderer.render(scene, camera); }

    </script>
</body>
</html>
